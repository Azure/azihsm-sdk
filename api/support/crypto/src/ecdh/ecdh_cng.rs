// Copyright (C) Microsoft Corporation. All rights reserved.

#![warn(missing_docs)]

use windows::Win32::Foundation::STATUS_SUCCESS;
use windows::Win32::Security::Cryptography::*;

use super::*;
use crate::eckey::*;

/// A wrapper struct for a CNG (Cryptography Next Generation) secret key handle.
///
/// This struct encapsulates a `BCRYPT_SECRET_HANDLE`, which represents a handle to a secret agreement value
/// generated by the Windows CNG API during Elliptic Curve Diffie-Hellman (ECDH) key exchange operations.
/// It is used to manage the lifetime and safety of the underlying native handle within Rust code.
struct CngSecretKeyHandle {
    secret_key_handle: BCRYPT_SECRET_HANDLE,
}

/// Implements the `Drop` trait for `CngSecretKeyHandle` to ensure that the underlying
/// CNG secret key handle is securely destroyed when the struct goes out of scope.
///
/// This is necessary to prevent resource leaks and to ensure that sensitive cryptographic
/// material is properly cleaned up, as the Windows CNG API requires explicit destruction
/// of secret handles via `BCryptDestroySecret`.
///
/// The `drop` function is called automatically by Rust when the struct is dropped,
/// providing a safe and idiomatic way to manage native resources.
impl Drop for CngSecretKeyHandle {
    /// drop SecretHandle when struct goes out of context
    #[allow(unsafe_code)]
    fn drop(&mut self) {
        // SAFETY: calls BCryptDestroySecret; the handle is valid and owned by this struct
        let status = unsafe { BCryptDestroySecret(self.secret_key_handle) };
        if status != STATUS_SUCCESS {
            tracing::error!("BCryptDestroySecret failed: {status:?}");
        }
    }
}

impl EcdhKeyDeriveOp for EcPrivateKey {
    /// Derives a shared secret using Elliptic Curve Diffie-Hellman (ECDH).
    ///
    /// # Arguments
    ///
    /// * `public_key` - Reference to the peer's public elliptic curve key (`EcPublicKey`).
    /// * `derived_key` - Mutable byte slice to store the derived shared secret.
    ///
    /// # Returns
    ///
    /// * `Ok(&[u8])` - A slice referencing the derived shared secret on success.
    /// * `Err(CryptoError)` - If key derivation fails.
    #[allow(unsafe_code)]
    fn ecdh_key_derive<'a>(
        &self,
        public_key: &EcPublicKey,
        derived_key: &'a mut [u8],
    ) -> Result<&'a [u8], CryptoError> {
        // Lock the private key handle for thread-safe access
        let private_handle = self.private_key_handle.lock().map_err(|e| {
            tracing::error!("Failed to lock private key handle: {:?}", e);
            CryptoError::EcdhInternalError
        })?;

        // Lock the public key handle for thread-safe access
        let public_handle = public_key.public_key_handle.lock().map_err(|e| {
            tracing::error!("Failed to lock public key handle: {:?}", e);
            CryptoError::EcdhInternalError
        })?;

        // Prepare a handle for the secret agreement result
        let mut secret_handle: CngSecretKeyHandle = CngSecretKeyHandle {
            secret_key_handle: BCRYPT_SECRET_HANDLE::default(),
        };
        // SAFETY: priv_key_handle and pub_key_handle are valid CNG key handles for ECDH; secret_handle is valid for output. This calls the Windows CNG API to perform ECDH secret agreement.
        let status = unsafe {
            BCryptSecretAgreement(
                private_handle.cng_ecdh_private_key,
                public_handle.cng_ecdh_public_key,
                &mut secret_handle.secret_key_handle,
                0,
            )
        };
        if status.is_err() {
            tracing::error!("BCryptSecretAgreement failed: {:?}", status);
            return Err(CryptoError::EcdhKeyAgreementFailed);
        }

        // Query the required size of the derived key
        let mut result_len: u32 = 0;
        // SAFETY: secret_handle is a valid secret agreement handle; result_len is valid for output. This queries the size of the derived key.
        let status = unsafe {
            BCryptDeriveKey(
                secret_handle.secret_key_handle,
                BCRYPT_KDF_RAW_SECRET,
                None,
                None,
                &mut result_len,
                0,
            )
        };
        if status.is_err() {
            tracing::error!("BCryptDeriveKey (size query) failed: {:?}", status);
            return Err(CryptoError::EcdhKeyDerivationFailed);
        }

        // Check if the provided output buffer is large enough
        if derived_key.len() < result_len as usize {
            tracing::error!(
                "Output buffer too small: need {}, got {}",
                result_len,
                derived_key.len()
            );
            return Err(CryptoError::EcdhBufferTooSmall);
        }

        // Derive the actual shared secret into the output buffer
        // SAFETY: secret_handle is valid, derived_key is allocated and sized, result_len is valid for output. This derives the actual shared secret.
        let status = unsafe {
            BCryptDeriveKey(
                secret_handle.secret_key_handle,
                BCRYPT_KDF_RAW_SECRET,
                None,
                Some(derived_key),
                &mut result_len,
                0,
            )
        };
        if status.is_err() {
            tracing::error!("BCryptDeriveKey failed: {:?}", status);
            return Err(CryptoError::EcdhKeyDerivationFailed);
        }

        // Return a slice of the derived key with the actual length
        Ok(&derived_key[..result_len as usize])
    }

    /// Returns the size in bytes of the derived key for the current ECDH context.
    ///
    /// # Returns
    ///
    /// * `Ok(usize)` - The size of the derived key in bytes.
    /// * `Err(CryptoError)` - If the size cannot be determined.
    #[allow(unsafe_code)]
    fn ecdh_get_derived_key_size(&self) -> Result<usize, CryptoError> {
        let private_handle = self.private_key_handle.lock().map_err(|e| {
            tracing::error!("Failed to lock private key handle: {:?}", e);
            CryptoError::EcdhInternalError
        })?;

        let mut key_length: u32 = 0;
        let mut result_len: u32 = 0;

        // SAFETY: private_handle is a valid CNG key handle; key_length and result_len are valid for output. This queries the key size from the CNG API.
        let status = unsafe {
            BCryptGetProperty(
                private_handle.cng_private_key,
                BCRYPT_KEY_LENGTH,
                Some(std::slice::from_raw_parts_mut(
                    &mut key_length as *mut u32 as *mut u8,
                    std::mem::size_of::<u32>(),
                )),
                &mut result_len,
                0,
            )
        };

        if status.is_err() {
            tracing::error!("BCryptGetProperty(BCRYPT_KEY_LENGTH) failed: {:?}", status);
            return Err(CryptoError::EcdhGetKeySizeFailed);
        }
        // Windows CNG returns the key length in bits (e.g., 521 for P-521). The shared secret must be padded to the next full byte.
        // For P-521, this is 521 bits, which is 66 bytes (521/8 = 65.125, round up to 66).
        // We use (key_length + 7) / 8 to ensure correct padding for all curves.
        Ok((key_length as usize).div_ceil(8))
    }
}
