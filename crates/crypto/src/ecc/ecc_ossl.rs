// Copyright (C) Microsoft Corporation. All rights reserved.

//! OpenSSL-based Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
//!
//! This module provides ECDSA signature generation and verification using OpenSSL
//! as the underlying cryptographic backend. It supports NIST standard curves
//! (P-256, P-384, P-521) for digital signatures.
//!
//! # ECDSA Algorithm
//!
//! ECDSA (Elliptic Curve Digital Signature Algorithm) is a cryptographic algorithm
//! used to generate and verify digital signatures. It provides:
//! - **Authentication**: Verifies the identity of the signer
//! - **Non-repudiation**: Signer cannot deny having signed the message
//! - **Integrity**: Detects any modifications to the signed data
//!
//! # Signature Format
//!
//! Signatures are generated in DER-encoded format, containing two integers (r, s)
//! that form the ECDSA signature. The signature size depends on the curve:
//! - P-256: ~70-72 bytes
//! - P-384: ~102-104 bytes
//! - P-521: ~137-139 bytes
//!
//! # Security Considerations
//!
//! - Always use a cryptographically secure hash function (SHA-256 or stronger)
//! - Private keys must be kept secure and never shared
//! - Each signature uses a unique random value (nonce) generated securely
//! - Verify signatures before trusting signed data

use openssl::pkey_ctx::*;

use super::*;

/// OpenSSL ECDSA signature and verification operations.
///
/// This structure provides stateless ECDSA operations for signing and verifying
/// data with elliptic curve keys. It implements the `SignOp` and `VerifyOp` traits
/// for NIST curves (P-256, P-384, P-521).
///
/// # Thread Safety
///
/// This structure is thread-safe and can be used concurrently from multiple threads.
/// Each operation creates its own OpenSSL context.
#[derive(Default)]
pub struct OsslEccAlgo {}

impl SignOp for OsslEccAlgo {
    type Key = EccPrivateKey;

    /// Generates an ECDSA signature for the provided data.
    ///
    /// This method creates a digital signature using the private key. The signature
    /// is deterministic based on the input data and the random nonce generated by
    /// OpenSSL's secure random number generator.
    ///
    /// # Arguments
    ///
    /// * `key` - The ECC private key used for signing
    /// * `data` - The data to sign (typically a hash of the original message)
    /// * `signature` - Optional output buffer. If `None`, returns the required buffer size.
    ///
    /// # Returns
    ///
    /// The number of bytes written to the signature buffer, or the required buffer size
    /// if `signature` is `None`. The signature size depends on the curve:
    /// - P-256: ~70-72 bytes
    /// - P-384: ~102-104 bytes  
    /// - P-521: ~137-139 bytes
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - `CryptoError::EccError` - Context initialization fails
    /// - `CryptoError::EccSignError` - Signing operation fails
    ///
    /// # Security
    ///
    /// - Always hash the input data before signing (e.g., with SHA-256)
    /// - Never sign raw user input directly
    /// - Each signature uses a unique cryptographically secure random nonce
    fn sign(
        &mut self,
        key: &Self::Key,
        data: &[u8],
        signature: Option<&mut [u8]>,
    ) -> Result<usize, CryptoError> {
        let len = key.curve().point_size() * 2;
        if let Some(signature) = signature {
            if signature.len() < len {
                return Err(CryptoError::EccSignError);
            }

            let mut ctx = PkeyCtx::new(key.pkey()).map_err(|_| CryptoError::EccError)?;

            ctx.sign_init().map_err(|_| CryptoError::EccSignError)?;

            let len = ctx
                .sign(data, None)
                .map_err(|_| CryptoError::EccSignError)?;

            let mut vec = vec![0u8; len];

            let len = ctx
                .sign(data, Some(&mut vec))
                .map_err(|_| CryptoError::EccSignError)?;

            let der = DerEccSignature::from_der(key.curve(), &vec[..len])?;

            signature[..key.curve().point_size()].copy_from_slice(der.r());
            signature[key.curve().point_size()..].copy_from_slice(der.s());
        }

        Ok(len)
    }
}

impl VerifyOp for OsslEccAlgo {
    type Key = EccPublicKey;

    /// Verifies an ECDSA signature against the provided data.
    ///
    /// This method checks whether the signature is valid for the given data and
    /// public key. It uses the public key to verify that the signature was created
    /// by the corresponding private key.
    ///
    /// # Arguments
    ///
    /// * `key` - The ECC public key used for verification
    /// * `data` - The data that was signed (typically a hash of the original message)
    /// * `signature` - The signature to verify (DER-encoded)
    ///
    /// # Returns
    ///
    /// Returns `Ok(true)` if the signature is valid, `Ok(false)` if the signature is
    /// invalid (does not match the data and key).
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - `CryptoError::EccError` - Context initialization fails
    /// - `CryptoError::EccVerifyError` - Verification operation fails (malformed signature)
    ///
    /// # Security
    ///
    /// - Always use the same hash algorithm for verification as was used for signing
    /// - Invalid signatures return `Ok(false)`, not an error
    /// - Malformed signatures that cannot be parsed return an error
    fn verify(
        &mut self,
        key: &Self::Key,
        data: &[u8],
        signature: &[u8],
    ) -> Result<bool, CryptoError> {
        let len = key.curve().point_size() * 2;
        if signature.len() != len {
            Err(CryptoError::EccVerifyError)?
        }

        let der_sig = DerEccSignature::new(
            key.curve(),
            &signature[..key.curve().point_size()],
            &signature[key.curve().point_size()..],
        )?;

        let der_len = der_sig.to_der(None)?;
        let mut der = vec![0u8; der_len];
        let der_len = der_sig.to_der(Some(&mut der))?;

        let mut ctx = PkeyCtx::new(key.pkey()).map_err(|_| CryptoError::EccError)?;
        ctx.verify_init().map_err(|_| CryptoError::EccVerifyError)?;

        // Returns true for valid signatures, false for invalid ones.
        //
        // The underlying OpenSSL function (EVP_PKEY_verify) may return an error
        // when encountering malformed signatures or corrupt data rather than returning false.
        // We treat such errors as invalid signatures and return false.
        ctx.verify(data, &der[..der_len]).or(Ok(false))
    }
}
