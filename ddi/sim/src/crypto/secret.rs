// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! Module for describing unstructured bits and key derivation functions.

use crate::crypto::hmac::HmacKey;
use crate::crypto::hmac::HmacOp;
use crate::crypto::sha::HashAlgorithm;
use crate::errors::ManticoreError;
use crate::mask::KeySerialization;
use crate::table::entry::Kind;

/// Trait for Secret operations
pub trait SecretOp {
    /// Create a `SecretKey` instance from array of bits,
    /// such as the output from ECDH key exchange.
    ///
    /// # Arguments
    /// * `bytes` - Array of bits
    ///
    /// # Returns
    /// * `SecretKey` - The created instance.
    ///
    /// # Errors
    /// * `ManticoreError::InvalidArgument` - If the raw data has invalid size.
    fn from_bytes(bytes: &[u8]) -> Result<Self, ManticoreError>
    where
        Self: Sized;

    /// Use HKDF to derive bytes from this Secret.
    ///
    /// # Arguments
    /// * `hash_algorithm` - Hash algorithm, e.g. SHA256
    /// * `salt` - optional salt value
    /// * `info` - optional context and application specific information
    /// * `out_len` - size of derived bits
    ///
    /// # Returns
    /// * Vec<u8> of derived bytes
    fn hkdf_derive(
        &self,
        hash_algorithm: HashAlgorithm,
        salt: Option<&[u8]>,
        info: Option<&[u8]>,
        out_len: usize,
    ) -> Result<Vec<u8>, ManticoreError>;

    /// Use KBKDF (SP800-108) with "Counter" mode and HMAC to derive bytes.
    ///
    /// # Arguments
    /// * `hash_algorithm` - Hash algorithm, e.g. SHA256
    /// * `label` - optional label value, aka "salt" in OpenSSL
    /// * `context` - optional context and application specific information, aka "info" in OpenSSL
    /// * `use_l` - whether to use optional 'L', "true" is default
    /// * `use_seperator` - whether to use optional 'zero seperator', "true" is default
    /// * `out_len` - size of derived bytes
    ///
    /// # Returns
    /// * Vec<u8> of derived bytes
    fn kbkdf_counter_hmac_derive(
        &self,
        hash_algorithm: HashAlgorithm,
        salt: Option<&[u8]>,
        info: Option<&[u8]>,
        use_l: bool,
        use_seperator: bool,
        out_len: usize,
    ) -> Result<Vec<u8>, ManticoreError>;
}

/// Supported Secret sizes
/// Size of output from ECDH key exchange correspond to input ECC key sizes
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum SecretSize {
    /// 256-bit key.
    Secret256,

    /// 384-bit key.
    Secret384,

    /// 521-bit key.
    Secret521,
}

/// Bits generated by key exchange.
#[derive(Debug, Clone)]
pub struct SecretKey {
    key: Vec<u8>,
    #[allow(unused)]
    size: SecretSize,
}

impl KeySerialization<SecretKey> for SecretKey {
    fn serialize(&self) -> Result<Vec<u8>, ManticoreError> {
        Ok(self.key.clone())
    }

    fn deserialize(raw: &[u8], expected_type: Kind) -> Result<SecretKey, ManticoreError> {
        match expected_type {
            Kind::Secret256 | Kind::Secret384 | Kind::Secret521 => SecretKey::from_bytes(raw),
            _ => {
                tracing::error!(error=?ManticoreError::DerAndKeyTypeMismatch, ?expected_type, "Expected type not Secret when deserializing sealed key for SecretKey");
                Err(ManticoreError::DerAndKeyTypeMismatch)
            }
        }
    }
}

impl SecretOp for SecretKey {
    fn from_bytes(bytes: &[u8]) -> Result<Self, ManticoreError> {
        let size = match bytes.len() {
            32 => SecretSize::Secret256,
            48 => SecretSize::Secret384,
            66 => SecretSize::Secret521,
            invalid_bytes_len => {
                tracing::error!(invalid_bytes_len, "Invalid Secret size");
                Err(ManticoreError::InvalidArgument)?
            }
        };

        Ok(Self {
            key: bytes.to_vec(),
            size,
        })
    }

    fn hkdf_derive(
        &self,
        hash_algorithm: HashAlgorithm,
        salt: Option<&[u8]>,
        info: Option<&[u8]>,
        out_len: usize,
    ) -> Result<Vec<u8>, ManticoreError> {
        // Step1 : Extract
        // HKDF-Extract(salt, IKM) -> PRK
        // Hash function is optional
        let salt = match salt {
            Some(salt) => salt.to_vec(),
            None => Vec::new(),
        };
        let hmac_key = HmacKey::from_bytes(salt.as_slice())?;
        let prk = hmac_key.hmac(self.key.as_slice(), hash_algorithm)?;

        // Step 2: Expand
        // HKDF-Expand(PRK, info, L) -> OKM
        // Inputs:
        //    PRK : a pseudorandom key of at least HashLen octets
        //          (usually, the output from the extract step)
        //    info : optional context and application specific information
        //          (can be a zero-length string)
        //    L : length of output keying material in octets
        // Output:
        //    OKM output keying material (of L octets)
        //
        // The output OKM is calculated as follows:
        // N = ceil(L/HashLen)
        // T = T(1) | T(2) | T(3) | ... | T(N)
        // OKM = first L octets of T
        // where:
        // T(0) = empty string (zero length)
        // T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)
        // T(2) = HMAC-Hash(PRK, T(1) | info | 0x02)
        // T(3) = HMAC-Hash(PRK, T(2) | info | 0x03)
        // ...

        let iter_num = out_len.div_ceil(hash_algorithm.digest_size());

        let mut t_prev = Vec::new();
        let mut t = Vec::new();
        let hmac_key = HmacKey::from_bytes(prk.as_slice())?;
        for i in 1..=iter_num {
            // T(i) = HMAC-Hash(PRK, T(i-1) | info | i)
            let mut msg = Vec::new();
            if i > 1 {
                msg.extend_from_slice(t_prev.as_slice());
            }
            if let Some(info) = info {
                msg.extend_from_slice(info);
            }
            msg.push(i as u8);

            let t_new = hmac_key.hmac(&msg, hash_algorithm)?;
            t.extend_from_slice(&t_new);
            t_prev = t_new;
        }

        if t.len() < out_len {
            Err(ManticoreError::HkdfError)?
        }
        Ok(t[..out_len].to_vec())
    }

    fn kbkdf_counter_hmac_derive(
        &self,
        hash_algorithm: HashAlgorithm,
        label: Option<&[u8]>,
        context: Option<&[u8]>,
        use_l: bool,
        use_seperator: bool,
        out_len: usize,
    ) -> Result<Vec<u8>, ManticoreError> {
        let hash_len = hash_algorithm.digest_size();

        // Concatenate the input message
        // input message = ([i]2 || Label || 0x00 || Context || [L]2)
        let mut msg: Vec<u8> = Vec::new();
        let mut msg_len = 0;

        // [i]2 is the size of the iteration depenedent input data.
        // Size of the counter is 4 bytes
        msg_len += 4;
        msg.resize(msg_len, 0);

        // copy the Label
        if let Some(label) = label {
            msg.extend_from_slice(label);
        }

        // 0x00 is the seperator
        if use_seperator {
            msg.push(0x00);
        }

        // copy the Context
        if let Some(context) = context {
            msg.extend_from_slice(context);
        }

        // [L]2 is the length of the output in bits
        if use_l {
            let l: u32 = out_len as u32 * 8;
            let l_bytes = l.to_be_bytes();
            msg.extend_from_slice(&l_bytes);
        }

        // Process:
        //
        // 1. n := ceil(L/h).
        // 2. If n > 2^r−1, then output an error indicator and stop (i.e., skip steps 3, 4, and 5).
        // 3. result := ∅.
        // 4. For i = 1 to n, do
        //     a. K(i) := PRF (KIN, [i]2 || Label || 0x00 || Context || [L]2),
        //     b. result := result || K(i).
        // 5. KOUT := the leftmost L bits of result
        //
        // If n > 2^r−1, then output an error indicator and stop.
        // This is guaranteed to work because out_len <= KDF_MAX_SECRET_SIZE and hash_len >= 1

        // n := ceil(L/h)
        let iter_num: u32 = (out_len as u16).div_ceil(hash_len as u16).into();

        let mut output: Vec<u8> = Vec::new();

        let hmac_key = HmacKey::from_bytes(self.key.as_slice())?;

        // 4. For i = 1 to n, do
        for i in 1..(iter_num + 1) {
            // update [i]2 value
            let i_bytes = i.to_be_bytes();
            msg[..4].copy_from_slice(&i_bytes);
            // a. K(i) := PRF (KIN, [i]2 || Label || 0x00 || Context || [L]2)
            let k_i = hmac_key.hmac(&msg, hash_algorithm)?;

            // b. result := result || K(i).
            output.extend_from_slice(&k_i);
        }

        // Sanity checks
        if output.len() < out_len {
            Err(ManticoreError::KbkdfError)?
        }

        Ok(output[..out_len].to_vec())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Steps to generate collateral for KDF tests. Use openssl utility in Linux/WSL:
    // 1- openssl rand -out secret_256 32
    // 2- SECRET_256_HEX=$(hexdump -v -e '/1 "%02X"' < secret_256)

    // 3- openssl kdf -keylen 32 -kdfopt digest:SHA2-256 -kdfopt hexkey:$SECRET_256_HEX -kdfopt salt:salt -kdfopt info:label -out hkdf_output HKDF
    // 4- sed '1s/^/0x/;s/:/,0x/g' hkdf_output > hkdf_output.hex

    // 6- openssl kdf -keylen 32 -kdfopt digest:SHA2-256 -kdfopt hexkey:$SECRET_256_HEX -kdfopt mode:counter -kdfopt mac:hmac -kdfopt salt:label -kdfopt info:context -out kbkdf_output KBKDF
    // 7- sed '1s/^/0x/;s/:/,0x/g' kbkdf_output > kbkdf_output.hex

    // 8- hexdump -v -e '/1 "0x%02X,"' < secret_256 > secret_256.hex
    // 9- Copy the content of secret_256.hex, hkdf_output.hex, kbkdf_output.hex below
    const TEST_SECRET_256_KEY: [u8; 32] = [
        0x03, 0xCB, 0x17, 0x79, 0xBB, 0xD8, 0xF6, 0xE8, 0x8C, 0x59, 0x45, 0x9D, 0xAC, 0xE5, 0x0C,
        0x29, 0x17, 0x9C, 0x92, 0xBE, 0x23, 0x66, 0xA4, 0x68, 0xCB, 0x82, 0xAD, 0x83, 0xAD, 0xE1,
        0x51, 0xA5,
    ];

    const TEST_HKDF_256_OUTPUT: [u8; 32] = [
        0x84, 0xCB, 0xCC, 0x68, 0xC9, 0xAD, 0xF7, 0x27, 0xB5, 0xD8, 0xD8, 0xCD, 0x19, 0xFD, 0x50,
        0x75, 0x89, 0x7B, 0x14, 0x37, 0x1F, 0xC0, 0xF1, 0x29, 0xED, 0x19, 0x77, 0xC6, 0x18, 0x44,
        0xDC, 0x6B,
    ];

    const TEST_KBKDF_256_OUTPUT: [u8; 32] = [
        0x4E, 0x95, 0x7D, 0xCB, 0x1B, 0x62, 0x85, 0x37, 0x5D, 0x79, 0x86, 0xBB, 0x4B, 0x3E, 0xF6,
        0xEE, 0x87, 0xD5, 0xFA, 0xF2, 0xDB, 0x58, 0x41, 0xBB, 0x68, 0x81, 0x59, 0x6B, 0x16, 0x26,
        0xB5, 0xBC,
    ];

    #[test]
    fn test_hkdf() {
        let secret_key = SecretKey::from_bytes(&TEST_SECRET_256_KEY).unwrap();

        let algo = HashAlgorithm::Sha256;
        let salt = "salt".as_bytes().to_vec();
        let info = "label".as_bytes().to_vec();

        let output = secret_key.hkdf_derive(algo, Some(&salt), Some(&info), 32);
        assert!(output.is_ok());
        let output = output.unwrap();

        assert_eq!(output, TEST_HKDF_256_OUTPUT);
    }

    #[test]
    fn test_kbkdf() {
        let secret_key = SecretKey::from_bytes(&TEST_SECRET_256_KEY).unwrap();

        let algo = HashAlgorithm::Sha256;
        let label = "label".as_bytes().to_vec();
        let context = "context".as_bytes().to_vec();
        let use_l = true;
        let use_seperator = true;

        let output = secret_key.kbkdf_counter_hmac_derive(
            algo,
            Some(&label),
            Some(&context),
            use_l,
            use_seperator,
            32,
        );
        assert!(output.is_ok());
        let output = output.unwrap();

        assert_eq!(output, TEST_KBKDF_256_OUTPUT);
    }
}
