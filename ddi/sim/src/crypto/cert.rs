// Copyright (C) Microsoft Corporation. All rights reserved.

//! Module for HACKY generation of Manticore Attestation Key Certificates

use der::Encode;
use p384::ecdsa::signature::Signer;
use p384::ecdsa::DerSignature;
use p384::pkcs8::DecodePrivateKey;

use crate::errors::ManticoreError;

/// Template for mock Manticore Attestation Key Certificate, in DER
/// The Attest Key should be an ECC P-384 key
/// Everything (subject, issuer, serial number, extensions) is hardcoded
/// Validity hardcoded as 2025-09-30 to 2036-09-30
/// Only replace the SubjectPublicKeyInfo and signature at runtime
/// To generate new one, see function generate_cert at the bottom of this file
const TEMPLATE_DER_CERTIFICATE: [u8; 413] = [
    0x30, 0x82, 0x01, 0x99, 0x30, 0x82, 0x01, 0x20, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01,
    0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x03, 0x30, 0x16, 0x31, 0x14,
    0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x0B, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65,
    0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x35, 0x30, 0x39, 0x33, 0x30, 0x32, 0x31,
    0x30, 0x39, 0x34, 0x33, 0x5A, 0x17, 0x0D, 0x33, 0x36, 0x30, 0x39, 0x33, 0x30, 0x32, 0x31, 0x30,
    0x39, 0x34, 0x33, 0x5A, 0x30, 0x16, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C,
    0x0B, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x76, 0x30, 0x10,
    0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22,
    0x03, 0x62, 0x00, 0x04, 0xBA, 0xD2, 0xDD, 0x78, 0x00, 0x29, 0x36, 0x27, 0x66, 0x20, 0xBF, 0x46,
    0x7D, 0x04, 0x9A, 0x60, 0xA8, 0x67, 0xB9, 0x3D, 0x6D, 0x55, 0xC3, 0x8B, 0xA9, 0xCB, 0x61, 0x5B,
    0x30, 0xD6, 0x45, 0x8D, 0xE6, 0x29, 0x56, 0xB7, 0xFC, 0xCF, 0x64, 0x1D, 0xCF, 0xFD, 0xB7, 0xF2,
    0xF3, 0x5A, 0x47, 0xD2, 0xF9, 0x76, 0x64, 0xD3, 0xBF, 0x3A, 0x2C, 0x0E, 0xCB, 0x1F, 0xD2, 0x9B,
    0x1E, 0xFD, 0xB7, 0xCD, 0x97, 0xBF, 0x85, 0xD9, 0x86, 0xC5, 0x47, 0xC3, 0x9B, 0xC2, 0x57, 0x5D,
    0x6C, 0x33, 0x18, 0x0D, 0xF8, 0x16, 0x9B, 0x07, 0x23, 0xE6, 0x4A, 0xCC, 0x03, 0x9C, 0xCE, 0xEF,
    0x0A, 0xB4, 0x20, 0x23, 0xA3, 0x42, 0x30, 0x40, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04,
    0x16, 0x04, 0x14, 0x33, 0xCB, 0x5B, 0xDD, 0x34, 0x37, 0x62, 0xDD, 0x0E, 0x62, 0xB3, 0x0F, 0x5E,
    0x6E, 0x29, 0xB1, 0x00, 0xE2, 0xEB, 0x2F, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01,
    0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01,
    0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE,
    0x3D, 0x04, 0x03, 0x03, 0x03, 0x67, 0x00, 0x30, 0x64, 0x02, 0x30, 0x7E, 0x7E, 0xE4, 0x21, 0xF6,
    0x1F, 0x21, 0x97, 0xAC, 0xEE, 0xC1, 0xAC, 0x41, 0xE8, 0xA5, 0x39, 0x2F, 0x46, 0x87, 0xF7, 0x26,
    0x6F, 0xD5, 0x2D, 0xB8, 0x99, 0x97, 0xA9, 0xC1, 0x4F, 0x7E, 0xD4, 0xFC, 0x12, 0x25, 0x7A, 0x6D,
    0x34, 0x54, 0x47, 0xC1, 0x5B, 0x04, 0xFF, 0x58, 0x8D, 0x44, 0xC1, 0x02, 0x30, 0x23, 0x92, 0x67,
    0xE2, 0xB3, 0xB8, 0x62, 0x97, 0xF2, 0xDA, 0x68, 0x10, 0xC2, 0xA6, 0x52, 0x87, 0xF0, 0x13, 0x79,
    0x0F, 0x95, 0x2F, 0x59, 0xE7, 0xCB, 0x78, 0xD7, 0x32, 0xF6, 0x6B, 0xEB, 0xD1, 0xC1, 0x77, 0x86,
    0x77, 0xBD, 0x92, 0x83, 0x78, 0x59, 0x67, 0x5E, 0x14, 0x01, 0xCF, 0x3D, 0x1F,
];

/// DER Sequence Tag
const DER_SEQ_TAG: u8 = 0x30;

/// DER AlgorithmIdentifier for ECDSA with SHA-384
const SIG_ALG_PORTION: [u8; 12] = [48, 10, 6, 8, 42, 134, 72, 206, 61, 4, 3, 3];

// Various offset for the template buffer
// TBS starts at offset 4
const TBS_OFFSET: usize = 4;
const TBS_LENGTH: usize = 292;

// Subject Public Key Info
const SPKI_OFFSET: usize = 108;
const SPKI_LENGTH: usize = 120;

/// Construct Signature BitString
fn recreate_signature_portion(signature: &DerSignature) -> Result<Vec<u8>, ManticoreError> {
    let mut buffer = Vec::new();

    let signature = signature.to_der().map_err(|err| {
        tracing::error!(?err, "Failed to encode signature to DER");
        ManticoreError::EccPubKeyCertGenerateError
    })?;

    // BIT STRING tag
    buffer.push(0x03);
    // Length
    // Unused bit + signature length
    buffer.push(signature.len() as u8 + 1);
    // Unused bits
    buffer.push(0x00);
    buffer.extend_from_slice(&signature);

    Ok(buffer)
}

/// Use the template, recalculate the signature, and create new cert
/// Expects P-384 key
pub fn recreate_cert(
    pub_key_der: &[u8],
    private_key_der: &[u8],
) -> Result<Vec<u8>, ManticoreError> {
    let der = &TEMPLATE_DER_CERTIFICATE;
    // Find TBS
    let mut tbs = der[TBS_OFFSET..TBS_OFFSET + TBS_LENGTH].to_vec();

    // Replace SPKI in TBS
    if SPKI_LENGTH != pub_key_der.len() {
        tracing::error!(
            expect = SPKI_LENGTH,
            actual = pub_key_der.len(),
            "Unexpected SPKI length"
        );
        return Err(ManticoreError::EccPubKeyCertGenerateError);
    }

    tbs[(SPKI_OFFSET - TBS_OFFSET)..(SPKI_OFFSET - TBS_OFFSET + SPKI_LENGTH)]
        .copy_from_slice(pub_key_der);

    // Prepare signing key from private key
    let key = p384::SecretKey::from_pkcs8_der(private_key_der).map_err(|err| {
        tracing::error!(?err, "Failed to parse private key DER");
        ManticoreError::EccPubKeyCertGenerateError
    })?;
    let signing_key = p384::ecdsa::SigningKey::from(key);

    // Sign the TBS to get signature
    let signature: DerSignature = signing_key.sign(&tbs);

    // Create Signature portion
    let portion_signature = recreate_signature_portion(&signature)?;

    let total_len = tbs.len() + SIG_ALG_PORTION.len() + portion_signature.len();
    if total_len > (u16::MAX as usize) {
        tracing::error!(total_len, "Certificate too long");
        return Err(ManticoreError::EccPubKeyCertGenerateError);
    }

    // Construct Certificate DER
    let mut new_der = Vec::new();
    {
        // Add first 4 bytes
        new_der.push(DER_SEQ_TAG);
        new_der.push(0x82);
        new_der.push((total_len >> u8::BITS) as u8);
        new_der.push(total_len as u8);

        // Add TBS portion
        new_der.extend_from_slice(&tbs);

        // Add signature algorithm portion
        new_der.extend_from_slice(&SIG_ALG_PORTION);

        // Add signature portion
        new_der.extend_from_slice(&portion_signature);
    }

    Ok(new_der)
}

/*
/// Example function to generate Attestation Key Certificate
/// Params:
/// - public_key_der: DER encoded SubjectPublicKeyInfo of the Attestation Key
/// - der: DER encoded PKCS#8 private key of the Attestation Key
fn generate_cert(public_key_der: &[u8], der: &[u8]) -> Vec<u8> {
    use der::Decode;
    use p384::ecdsa::DerSignature;
    use p384::pkcs8::DecodePrivateKey;
    use spki::SubjectPublicKeyInfo;
    use std::str::FromStr;
    use x509_cert::builder::Builder;
    use x509_cert::builder::CertificateBuilder;
    use x509_cert::builder::Profile;
    use x509_cert::name::Name;
    use x509_cert::serial_number::SerialNumber;
    use x509_cert::time::Validity;

    let public_key = SubjectPublicKeyInfo::from_der(&public_key_der).unwrap();

    let profile = Profile::Root;
    let serial_number = SerialNumber::from(1u32);
    let validity = Validity::from_now(std::time::Duration::new(365 * 24 * 60 * 60, 0)).unwrap();
    let subject = Name::from_str("CN=example.com").unwrap();

    let ec_key_p384 = p384::SecretKey::from_pkcs8_der(&der).unwrap();
    let signer = p384::ecdsa::SigningKey::from(ec_key_p384);

    let builder = CertificateBuilder::new(
        profile,
        serial_number,
        validity,
        subject,
        public_key,
        &signer,
    )
    .unwrap();

    let cert = builder.build::<DerSignature>().unwrap();
    cert.to_der().unwrap()
}
*/
