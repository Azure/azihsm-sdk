// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! Key Attestation Report Format in COSE_Sign1.

use bitfield_struct::bitfield;
use minicbor::CborLen;
use minicbor::Decode;
use minicbor::Encode;
use minicbor::Encoder;

use crate::errors::ManticoreError;

/// 0b110 (major type 6 for tag) | 10010 (CBOR Tag 18 for COSE_Sign1) \ h'd2
pub const COSE_SIGN1_TAG: u8 = 0xd2;

/// The size of the tag.
pub const COSE_SIGN1_TAG_SIZE: usize = 1;

/// The size of the encoded protected header.
pub const PROTECTED_HEADER_SIZE: usize = 22;

/// The maximum size of encoded payload.
pub const PAYLOAD_MAX_SIZE: usize = REPORT_MAX_ENCODING_BYTES
    + PUBLIC_KEY_MAX_SIZE
    + APP_UUID_SIZE
    + VM_LAUNCH_ID_SIZE
    + REPORT_DATA_SIZE;

/// Signature size for ES384.
pub const SIGNATURE_SIZE: usize = 96;

/// Extra bytes reserved for COSE_Sign1 encoding.
/// 1 byte: type array (0b100) | 4 (00100) \ h'84
/// 1 byte:   type bstr (0b010) | size 22 (10110) \ h'56
/// 1 byte:   type map  (0b101) | size 0 (00000) \ h'a0
/// 3 byte:   type bstr (0b010) | 2 bytes (11001) | size 689 (0x020d) \ h'5902af
/// 2 byte:   type bstr (0b010) | 1 byte (11000) | size 96 (0x60) \ h'5860
pub const COSE_SIGN1_ENCODING_BYTES: usize = 8;

/// Maximum size of the COSE_Sign1 object (untagged).
pub const COSE_SIGN1_OBJECT_MAX_SIZE: usize =
    PROTECTED_HEADER_SIZE + PAYLOAD_MAX_SIZE + SIGNATURE_SIZE + COSE_SIGN1_ENCODING_BYTES;

/// Maximum size of the tagged COSE_Sign1 object.
pub const TAGGED_COSE_SIGN1_OBJECT_MAX_SIZE: usize =
    COSE_SIGN1_TAG_SIZE + COSE_SIGN1_OBJECT_MAX_SIZE;

/// CBOR-encoded of the protected header.
/// / protected / h'a201382203706170706c69636174696f6e2f63626f72 / {
///     / alg / 1:-35 / ES384 /,
///     / content_type / 3:'application/cbor'
/// }
pub const PROTECTED_HEADER: [u8; PROTECTED_HEADER_SIZE] = [
    0xa2, 0x01, 0x38, 0x22, 0x03, 0x70, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x2f, 0x63, 0x62, 0x6f, 0x72,
];

/// Definition of COSE_Sign1 object.
/// See <https://www.rfc-editor.org/rfc/rfc9052> for more details.
#[derive(Encode, Decode, CborLen)]
#[cbor(array)]
pub struct CoseSign1Object<'a> {
    /// CBOR-encoded ProtectedHeader and wrapped in
    /// a bstr object.
    #[n(0)]
    #[cbor(with = "minicbor::bytes")]
    pub protected_header: [u8; PROTECTED_HEADER_SIZE],

    /// CBOR map.
    #[n(1)]
    pub unprotected_header: UnprotectedHeader,

    /// CBOR-encoded KeyAttestationReport and wrapped
    /// in a bstr object.
    /// The maximum size of the slice is `PAYLOAD_MAX_SIZE`.
    #[n(2)]
    #[cbor(with = "minicbor::bytes")]
    pub payload: &'a [u8],

    /// bstr.
    #[n(3)]
    #[cbor(with = "minicbor::bytes")]
    pub signature: [u8; SIGNATURE_SIZE],
}

impl<'a> CoseSign1Object<'a> {
    /// CBOR encoding of the struct.
    pub fn encode(&self, out: &mut [u8]) -> Result<usize, ManticoreError> {
        // Add the COSE_Sign1 tag.
        out[0] = COSE_SIGN1_TAG;

        minicbor::encode(self, &mut out[COSE_SIGN1_TAG_SIZE..])
            .map_err(|_| ManticoreError::CborEncodeError)?;

        Ok(COSE_SIGN1_TAG_SIZE + minicbor::len(self))
    }

    /// CBOR decoding of the struct.
    pub fn decode(data: &'a [u8]) -> Result<Self, ManticoreError> {
        // Check it begins with COSE_Sign1 tag.
        if data.len() < COSE_SIGN1_TAG_SIZE || data[0] != COSE_SIGN1_TAG {
            return Err(ManticoreError::CborDecodeError);
        }

        minicbor::decode(&data[COSE_SIGN1_TAG_SIZE..]).map_err(|_| ManticoreError::CborDecodeError)
    }
}

/// Definition of unprotected header.
#[derive(Copy, Clone, Encode, Decode, CborLen)]
#[cbor(map)]
pub struct UnprotectedHeader {}

/// The version of the report format.
pub const REPORT_VERSION: u16 = 1;

/// Maximum bytes reserved for CBOR encoding.
/// 1 byte: type map (0b101) | size 6 (00110) \ h'a6
/// 1 byte:   key 0 (0x00) \ h'00
/// 1 byte:     value 1 (0x01) \ h'01
/// 1 byte:   key 1 (0x01) \ h'01
/// 3 bytes:    value type bstr (0b010) | 2 byte (11001) | size 525 (0x020d) \ h'59020d
/// 1 byte:   key 2 (0x02) \ h'02
/// 1-3 bytes:  value u16
/// 1 byte:   key 3 (0x03) \ h'03
/// 1-5 bytes:  value u32
/// 1 byte:   key 4 (0x04) \ h'04
/// 1 byte:     value type bstr (0b010) | size 16 (10000) \ h'50
/// 1 byte:   key 5 (0x05) \ h'05
/// 2 bytes:    value type bstr (0b010) | 1 byte (11000) | size 128 (0x80) \ h'5880
pub const REPORT_MAX_ENCODING_BYTES: usize = 22;

/// Maximum size of the encoded public key.
/// 4k RSA public key: 512 (modulus) + 4 (exponent) + 9 (encoding_bytes) = 525
/// Encoding bytes are calculated as follows.
/// 1 byte: type map (0b101) | size 3 (00011) \ h'a3
/// 1 byte:   key 1 (0x01) \ h'01
/// 1 byte:     value 3 (0x03) \ h'03
/// 1 byte:   key -1 \ type int (0b001) | value 0 (00000) \ h'20
/// 3 bytes:    value type bstr (0b010) | 2 bytes (11001) | size 256 (0x0100) \ h'590100
/// 1 byte:   key -2 \ type int (0b001) | value 1 (00001) \ h'21
/// 1 byte:     value type bstr (0b010) | 4 (00100) | h'44
pub const PUBLIC_KEY_MAX_SIZE: usize = 525;

/// Size of the app uuid.
pub const APP_UUID_SIZE: usize = 16;

/// Size of the report data.
pub const REPORT_DATA_SIZE: usize = 128;

/// Size of the launch id.
pub const VM_LAUNCH_ID_SIZE: usize = 16;

/// Set of flags denoting capabilities and attributes of the key.
#[bitfield(u32)]
pub struct KeyFlags {
    /// Whether the key is imported.
    pub is_imported: bool,
    /// Whether the key availability is for session only.
    pub is_session_key: bool,
    /// Whether the key is generated inside the device.
    pub is_generated: bool,
    /// Whether the key can be used to encrypt.
    pub can_encrypt: bool,
    /// Whether the key can be used to decrypt.
    pub can_decrypt: bool,
    /// Whether the key can be used to sign.
    pub can_sign: bool,
    /// Whether the key can be used to verify.
    pub can_verify: bool,
    /// Whether the key can be used to wrap.
    pub can_wrap: bool,
    /// Whether the key can be used to unwrap.
    pub can_unwrap: bool,
    /// Whether the key can be used to derive other keys.
    pub can_derive: bool,
    #[bits(22)]
    pub _reserved: u32,
}

/// Definition of the key attestation report.
#[derive(Debug, CborLen, Clone, Encode, Decode)]
#[cbor(map)]
pub struct KeyAttestationReport {
    /// Report version.
    #[n(0)]
    pub version: u16,

    /// CBOR map of COSE Key object.
    #[n(1)]
    #[cbor(with = "minicbor::bytes")]
    pub public_key: [u8; PUBLIC_KEY_MAX_SIZE],

    /// Size in bytes of the public key encoding.
    #[n(2)]
    pub public_key_size: u16,

    /// 32-bit key flags defined by `KeyFlags`.
    #[n(3)]
    pub flags: u32,

    /// The UUID of the app that owns the key.
    /// Stored as 16 octet values according to <https://datatracker.ietf.org/doc/html/rfc4122>
    #[n(4)]
    #[cbor(with = "minicbor::bytes")]
    pub app_uuid: [u8; APP_UUID_SIZE],

    /// Custom data that is included into the report.
    /// It is typical to use this field to store hash (e.g: SHA-256) of some data,
    /// instead of the actual data.
    #[n(5)]
    #[cbor(with = "minicbor::bytes")]
    pub report_data: [u8; REPORT_DATA_SIZE],

    /// GUID set by the host driver to identify the launch during set resource
    /// operation from host to the device.
    #[n(6)]
    #[cbor(with = "minicbor::bytes")]
    pub vm_launch_id: [u8; VM_LAUNCH_ID_SIZE],
}

impl KeyAttestationReport {
    /// CBOR encoding of the struct.
    pub fn encode(&self, out: &mut [u8]) -> Result<usize, ManticoreError> {
        minicbor::encode(self, out).map_err(|_| ManticoreError::CborEncodeError)?;

        Ok(minicbor::len(self))
    }
}

/// CBOR-encoded "Signature1".
pub const SIG_STRUCTURE_CONTEXT: [u8; SIG_STRUCTURE_CONTEXT_SIZE] =
    [0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x31];

/// Size of CBOR-encoded "Signature1".
pub const SIG_STRUCTURE_CONTEXT_SIZE: usize = 10;

/// Extra bytes reserved for `SigSignature` encoding.
/// 1 byte: type array (0b100) | size 4 (00100) \ h'84
/// 1 byte:   type str (0b011) | size 10 (01010) \ h'6a
/// 1 byte:   type bstr (0b010) | size 22 \ h'56
/// 1 byte:   type bstr (0b010) | size 0 \ h'40
/// 3 bytes:  type bstr (0b010) | size 689 \ h'5902b1
pub const SIG_STRUCTURE_ENCODING_BYTES: usize = 7;

/// The encoding byte of a 4-entries array.
pub const COSE_SIGN1_ARRAY_4: u8 = 0x84;

/// The encoding byte of 10-length string.
pub const COSE_SIGN1_STR_10: u8 = 0x6a;

/// Maximum size of the SigStructure
pub const SIG_STRUCTURE_MAX_SIZE: usize = SIG_STRUCTURE_ENCODING_BYTES
    + SIG_STRUCTURE_CONTEXT_SIZE
    + PROTECTED_HEADER_SIZE
    + PAYLOAD_MAX_SIZE;

/// Create the encoding of `SigStructure`.
/// See Section 4.4, <https://www.rfc-editor.org/rfc/rfc9052> for more details.
/// / SigStructure / = [
///     / context / "Signature1",
///     / body_protected / protected_header in bstr,
///     / external_aad / empty bstr,
///     / payload / payload in bstr,
/// ]
pub fn encode_sig_struct(
    body_protected: &[u8],
    payload: &[u8],
    out: &mut [u8],
) -> Result<usize, ManticoreError> {
    let out_size = out.len();
    let mut index = 0;

    // Manual encoding of leading bytes to remove the str encoding
    // dependency from minicbor.
    out[index] = COSE_SIGN1_ARRAY_4;
    index += 1;
    out[index] = COSE_SIGN1_STR_10;
    index += 1;
    out[index..index + SIG_STRUCTURE_CONTEXT_SIZE].copy_from_slice(&SIG_STRUCTURE_CONTEXT[..]);
    index += SIG_STRUCTURE_CONTEXT_SIZE;

    let buffer_size = out_size - index;
    let mut encoder = Encoder::new(&mut out[index..]);

    encoder
        .bytes(body_protected)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(&[])
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(payload)
        .map_err(|_| ManticoreError::CborEncodeError)?;
    let payload_size = buffer_size - encoder.writer().len();

    Ok(index + payload_size)
}

// The following definitions are based on <https://www.iana.org/assignments/cose/cose.xhtml>.

/// The label of COSE Key Types.
pub const COSE_KEY_COMMON_PARAMETERS_KTY: u8 = 1;

/// The value of RSA key type.
pub const COSE_KEY_TYPES_RSA: u8 = 3;

/// The value of ECC (EC2) key type.
pub const COSE_KEY_TYPES_EC2: u8 = 2;

/// The label of RSA modulus n.
pub const COSE_KEY_TYPE_PARAMETERS_RSA_N: i8 = -1;

/// The label of RSA public exponent e.
pub const COSE_KEY_TYPE_PARAMETERS_RSA_E: i8 = -2;

/// The label of EC identifier,.
pub const COSE_KEY_TYPE_PARAMETERS_EC2_CRV: i8 = -1;

/// The label of ECC x-coordinate.
pub const COSE_KEY_TYPE_PARAMETERS_EC2_X: i8 = -2;

/// The label of ECC y-coordinate.
pub const COSE_KEY_TYPE_PARAMETERS_EC2_Y: i8 = -3;

/// Encode a RSA public key into `COSE_Key` format.
/// See Section 7, Key Objects in <https://www.rfc-editor.org/rfc/rfc9052>.
pub fn encode_rsa_public(n: &[u8], e: &[u8], out: &mut [u8]) -> Result<usize, ManticoreError> {
    let out_len = out.len();
    let mut encoder = Encoder::new(out);

    encoder
        .map(3)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .u8(COSE_KEY_COMMON_PARAMETERS_KTY)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .u8(COSE_KEY_TYPES_RSA)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(COSE_KEY_TYPE_PARAMETERS_RSA_N)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(n)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(COSE_KEY_TYPE_PARAMETERS_RSA_E)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(e)
        .map_err(|_| ManticoreError::CborEncodeError)?;

    // We can safely do the subtraction given that encoder already ensures the size
    // of the encoded data is bounded by the size of the buffer.
    Ok(out_len - encoder.writer().len())
}

/// Encode an ECC public key into `COSE_Key` format.
/// See Section 7, Key Objects in <https://www.rfc-editor.org/rfc/rfc9052>.
pub fn encode_ecc_public(
    crv: i8,
    x: &[u8],
    y: &[u8],
    out: &mut [u8],
) -> Result<usize, ManticoreError> {
    let out_len = out.len();
    let mut encoder = Encoder::new(out);

    encoder
        .map(4)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .u8(COSE_KEY_COMMON_PARAMETERS_KTY)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .u8(COSE_KEY_TYPES_EC2)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(COSE_KEY_TYPE_PARAMETERS_EC2_CRV)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(crv)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(COSE_KEY_TYPE_PARAMETERS_EC2_X)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(x)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .i8(COSE_KEY_TYPE_PARAMETERS_EC2_Y)
        .map_err(|_| ManticoreError::CborEncodeError)?
        .bytes(y)
        .map_err(|_| ManticoreError::CborEncodeError)?;

    // We can safely do the subtraction given that encoder already ensures the size
    // of the encoded data is bounded by the size of the buffer.
    Ok(out_len - encoder.writer().len())
}

#[cfg(test)]
mod tests {
    use super::*;

    // The size of the CBOR-encoded map in the report.
    const CBOR_ENCODE_MAP_SIZE: usize = 2;

    #[allow(clippy::too_many_arguments)]
    fn create_payload(
        version: u16,
        public_key: [u8; PUBLIC_KEY_MAX_SIZE],
        public_key_size: u16,
        flags: u32,
        app_uuid: [u8; 16],
        report_data: [u8; REPORT_DATA_SIZE],
        vm_launch_id: [u8; VM_LAUNCH_ID_SIZE],
        encoded_buffer: &mut Vec<u8>,
    ) -> Result<usize, ManticoreError> {
        let report = KeyAttestationReport {
            version,
            public_key,
            public_key_size,
            flags,
            app_uuid,
            report_data,
            vm_launch_id,
        };

        // Resize the buffer to accommodate the maximum size of the report.
        encoded_buffer.resize(minicbor::len(&report), 0);

        let len = report.encode(encoded_buffer)?;

        Ok(len)
    }

    #[test]
    fn test_payload() {
        const EXPECTED_PAYLOAD: [u8; 709] = [
            0xa7, 0x00, 0x01, 0x01, 0x59, 0x02, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x02, 0x19, 0xff, 0xff, 0x03, 0x1a, 0xff, 0xff, 0xff, 0xff, 0x04, 0x50, 0x02, 0x02,
            0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x05, 0x58, 0x80, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x50, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        ];

        let mut payload = Vec::<u8>::new();
        let result = create_payload(
            REPORT_VERSION,
            [1u8; PUBLIC_KEY_MAX_SIZE],
            0xffff,     // Forcing maximum encoding bytes
            0xffffffff, // Forcing maximum encoding bytes
            [2u8; 16],
            [3u8; REPORT_DATA_SIZE],
            [4u8; 16],
            &mut payload,
        );

        assert!(
            result.is_ok(),
            "Failed to create payload {:?}",
            result.err()
        );
        let payload_len = result.unwrap();
        assert_eq!(payload_len, PAYLOAD_MAX_SIZE + CBOR_ENCODE_MAP_SIZE);
        assert_eq!(payload, EXPECTED_PAYLOAD);
    }

    #[test]
    fn test_cose_sign1_object() {
        const EXPECTED_COSE_SIGN1_OBJECT: [u8; 836] = [
            0xd2, 0x84, 0x56, 0xa2, 0x01, 0x38, 0x22, 0x03, 0x70, 0x61, 0x70, 0x70, 0x6c, 0x69,
            0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x63, 0x62, 0x6f, 0x72, 0xa0, 0x59, 0x02,
            0xc5, 0xa7, 0x00, 0x01, 0x01, 0x59, 0x02, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x02, 0x19, 0xff, 0xff, 0x03, 0x1a, 0xff, 0xff, 0xff, 0xff, 0x04, 0x50, 0x02,
            0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x02, 0x05, 0x58, 0x80, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x50, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x58, 0x60, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        ];
        let mut cose_sign1_object_buffer =
            [0u8; TAGGED_COSE_SIGN1_OBJECT_MAX_SIZE + CBOR_ENCODE_MAP_SIZE];

        let mut payload = Vec::<u8>::new();
        let result = create_payload(
            REPORT_VERSION,
            [1u8; PUBLIC_KEY_MAX_SIZE],
            0xffff,     // Forcing maximum encoding bytes
            0xffffffff, // Forcing maximum encoding bytes
            [2u8; 16],
            [3u8; REPORT_DATA_SIZE],
            [4u8; VM_LAUNCH_ID_SIZE],
            &mut payload,
        );
        assert!(result.is_ok());
        let payload_len = result.unwrap();
        assert_eq!(payload_len, PAYLOAD_MAX_SIZE + CBOR_ENCODE_MAP_SIZE);

        let cose_sign1_object = CoseSign1Object {
            protected_header: PROTECTED_HEADER,
            unprotected_header: UnprotectedHeader {},
            payload: payload.as_slice(),
            signature: [4u8; 96],
        };
        let result = cose_sign1_object.encode(&mut cose_sign1_object_buffer);
        assert!(result.is_ok());
        assert_eq!(
            result.unwrap(),
            TAGGED_COSE_SIGN1_OBJECT_MAX_SIZE + CBOR_ENCODE_MAP_SIZE
        );
        assert_eq!(cose_sign1_object_buffer, EXPECTED_COSE_SIGN1_OBJECT);
    }

    #[test]
    fn test_sig_struct() {
        const EXPECTED_TBS: [u8; 748] = [
            0x84, 0x6a, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x31, 0x56, 0xa2,
            0x01, 0x38, 0x22, 0x03, 0x70, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69,
            0x6f, 0x6e, 0x2f, 0x63, 0x62, 0x6f, 0x72, 0x40, 0x59, 0x02, 0xc5, 0xa7, 0x00, 0x01,
            0x01, 0x59, 0x02, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x19, 0xff,
            0xff, 0x03, 0x1a, 0xff, 0xff, 0xff, 0xff, 0x04, 0x50, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x58, 0x80,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x03, 0x06, 0x50, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        ];

        let mut payload = Vec::<u8>::new();
        let result = create_payload(
            REPORT_VERSION,
            [1u8; PUBLIC_KEY_MAX_SIZE],
            0xffff,     // Forcing maximum encoding bytes
            0xffffffff, // Forcing maximum encoding bytes
            [2u8; 16],
            [3u8; REPORT_DATA_SIZE],
            [4u8; VM_LAUNCH_ID_SIZE],
            &mut payload,
        );
        assert!(result.is_ok());
        let payload_len = result.unwrap();
        assert_eq!(payload_len, PAYLOAD_MAX_SIZE + CBOR_ENCODE_MAP_SIZE);

        let mut sig_struct_buffer = [0u8; SIG_STRUCTURE_MAX_SIZE + CBOR_ENCODE_MAP_SIZE]; // +2 for the map size
        let result = encode_sig_struct(&PROTECTED_HEADER, &payload, &mut sig_struct_buffer);
        assert!(result.is_ok());
        assert_eq!(
            result.unwrap(),
            SIG_STRUCTURE_MAX_SIZE + CBOR_ENCODE_MAP_SIZE
        );
        assert_eq!(sig_struct_buffer, EXPECTED_TBS);
    }
}
