// Copyright (C) Microsoft Corporation. All rights reserved.

//! Module for Cryptographic Key Handles.

use crate::attestation::CoseKey;
use crate::crypto::aes::AesKey;
use crate::crypto::aeshmac::AesHmacKey;
use crate::crypto::ecc::EccCurve;
use crate::crypto::ecc::EccOp;
use crate::crypto::ecc::EccPrivateKey;
use crate::crypto::ecc::EccPublicKey;
use crate::crypto::hmac::HmacKey;
use crate::crypto::rsa::RsaOp;
use crate::crypto::rsa::RsaPrivateKey;
use crate::crypto::rsa::RsaPublicKey;
use crate::crypto::secret::SecretKey;
use crate::errors::ManticoreError;
use crate::function::ApiRev;
use crate::mask::KeySerialization;
use crate::table::entry::Kind;

#[derive(Debug, Clone)]
pub(crate) struct SessionKey {
    pub(crate) api_rev: ApiRev,
    pub(crate) masking_key: AesHmacKey,
}

/// Enumeration for storing Cryptographic Key Handles.
#[allow(clippy::large_enum_variant)]
#[derive(Debug, Clone)]
pub(crate) enum Key {
    /// RSA Private Key.
    RsaPrivate(RsaPrivateKey),

    /// RSA Public Key.
    #[allow(unused)]
    RsaPublic(RsaPublicKey),

    /// ECC Private Key.
    EccPrivate(EccPrivateKey),

    /// ECC Public Key.
    #[allow(unused)]
    EccPublic(EccPublicKey),

    /// AES Key.
    Aes(AesKey),

    /// AES and HMAC keys combined into one.
    /// Currently only used as Masking Key.
    AesHmac(AesHmacKey),

    /// Bits generated by key exchange.
    Secret(SecretKey),

    /// Session data including API revision, and masking key.
    Session(SessionKey),

    /// Hmac
    Hmac(HmacKey),
}

impl KeySerialization<Key> for Key {
    fn serialize(&self) -> Result<Vec<u8>, ManticoreError> {
        match self {
            Key::RsaPrivate(key) => key.serialize(),
            Key::RsaPublic(_key) => Err(ManticoreError::InvalidKeyType),
            Key::EccPrivate(key) => key.serialize(),
            Key::EccPublic(_key) => Err(ManticoreError::InvalidKeyType),
            Key::Aes(key) => key.serialize(),
            Key::Secret(key) => key.serialize(),
            Key::Hmac(key) => key.serialize(),
            Key::AesHmac(key) => key.serialize(),
            Key::Session(_) => Err(ManticoreError::InvalidKeyType),
        }
    }

    fn deserialize(raw: &[u8], expected_type: Kind) -> Result<Key, ManticoreError> {
        let imported_key = match expected_type {
            Kind::Aes128
            | Kind::Aes192
            | Kind::Aes256
            | Kind::AesXtsBulk256
            | Kind::AesGcmBulk256
            | Kind::AesGcmBulk256Unapproved => Key::Aes(AesKey::deserialize(raw, expected_type)?),
            Kind::AesHmac640 => Key::AesHmac(AesHmacKey::deserialize(raw, expected_type)?),
            Kind::Rsa2kPrivate
            | Kind::Rsa2kPrivateCrt
            | Kind::Rsa3kPrivate
            | Kind::Rsa3kPrivateCrt
            | Kind::Rsa4kPrivate
            | Kind::Rsa4kPrivateCrt => {
                Key::RsaPrivate(RsaPrivateKey::deserialize(raw, expected_type)?)
            }

            Kind::Ecc256Private | Kind::Ecc384Private | Kind::Ecc521Private => {
                Key::EccPrivate(EccPrivateKey::deserialize(raw, expected_type)?)
            }
            // ECC and RSA Public keys are not used
            Kind::Rsa2kPublic
            | Kind::Rsa3kPublic
            | Kind::Rsa4kPublic
            | Kind::Ecc256Public
            | Kind::Ecc384Public
            | Kind::Ecc521Public => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Unexpected key type when deserializing key: ECC Public or RSA Public key is not supported");
                Err(ManticoreError::InvalidKeyType)?
            }
            Kind::Secret256 | Kind::Secret384 | Kind::Secret521 => {
                Key::Secret(SecretKey::deserialize(raw, expected_type)?)
            }
            Kind::HmacSha256 | Kind::HmacSha384 | Kind::HmacSha512 => {
                Key::Hmac(HmacKey::deserialize(raw, expected_type)?)
            }
            Kind::Session => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Not supported to deserialize Session key");
                Err(ManticoreError::InvalidKeyType)?
            }
        };

        Ok(imported_key)
    }
}

impl TryFrom<&Key> for CoseKey {
    type Error = ManticoreError;
    fn try_from(key: &Key) -> Result<Self, Self::Error> {
        match key {
            Key::RsaPrivate(key) => {
                let n = key.modulus()?;
                let e = key.public_exponent()?;

                Ok(Self::RsaPublic { n, e })
            }
            Key::RsaPublic(key) => {
                let n = key.modulus()?;
                let e = key.public_exponent()?;

                Ok(Self::RsaPublic { n, e })
            }
            Key::EccPrivate(key) => {
                let curve_name = key.curve()?;

                // Based on Table 18, https://www.rfc-editor.org/rfc/rfc9053.html
                let crv = match curve_name {
                    EccCurve::P256 => 1,
                    EccCurve::P384 => 2,
                    EccCurve::P521 => 3,
                };

                let (x, y) = key.coordinates()?;

                Ok(Self::EccPublic { crv, x, y })
            }
            Key::EccPublic(key) => {
                let curve_name = key.curve()?;

                // Based on Table 18, https://www.rfc-editor.org/rfc/rfc9053.html
                let crv = match curve_name {
                    EccCurve::P256 => 1,
                    EccCurve::P384 => 2,
                    EccCurve::P521 => 3,
                };

                let (x, y) = key.coordinates()?;

                Ok(Self::EccPublic { crv, x, y })
            }
            Key::Aes(_) => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Key to be attested cannot be an AES key");
                Err(ManticoreError::InvalidKeyType)
            }
            Key::AesHmac(_) => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Key to be attested cannot be an AES-HMAC key");
                Err(ManticoreError::InvalidKeyType)
            }
            Key::Secret(_) => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Key to be attested cannot be a Secret key");
                Err(ManticoreError::InvalidKeyType)
            }
            Key::Hmac(_) => {
                tracing::error!(error = ?ManticoreError::InvalidKeyType, "Key to be attested cannot be an HMAC key");
                Err(ManticoreError::InvalidKeyType)
            }

            Key::Session(_) => Err(ManticoreError::InvalidKeyType),
        }
    }
}
