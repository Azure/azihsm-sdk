// Copyright (C) Microsoft Corporation. All rights reserved.

#![cfg(test)]
#[path = "common/helpers/mod.rs"]
#[allow(dead_code)]
#[allow(unused_imports)]
pub mod helpers;

use std::thread;

use azihsm_cred_encrypt::DeviceCredKey;
use azihsm_crypto::*;
use azihsm_ddi::*;
use azihsm_ddi_mbor::MborByteArray;
pub use azihsm_ddi_test_helpers::*;
use azihsm_ddi_types::*;
pub use helpers::*;
use x509::X509CertificateOp;
use x509::*;

// All the constants in this file are used by tests but for some reason clippy still thinks they
// are not used perhaps due to a bug so we mark each such constant with #[allow(dead_code)]

#[allow(dead_code)]
// 70FCF730-B876-4238-B835-8010CE8A3F76
pub(crate) const TEST_CRED_ID: [u8; 16] = [
    0x70, 0xFC, 0xF7, 0x30, 0xB8, 0x76, 0x42, 0x38, 0xB8, 0x35, 0x80, 0x10, 0xCE, 0x8A, 0x3F, 0x76,
];

#[allow(dead_code)]
// DB3DC77F-C22E-4300-80D4-1B31B6F04800
pub(crate) const TEST_CRED_PIN: [u8; 16] = [
    0xDB, 0x3D, 0xC7, 0x7F, 0xC2, 0x2E, 0x43, 0x00, 0x80, 0xD4, 0x1B, 0x31, 0xB6, 0xF0, 0x48, 0x00,
];

#[allow(dead_code)]
pub(crate) const TEST_SESSION_SEED: [u8; 48] = [
    0xe5, 0x1b, 0x8b, 0x4b, 0xa7, 0x94, 0xc7, 0xc8, 0xa2, 0x32, 0x84, 0xec, 0xad, 0x2b, 0x6a, 0xc,
    0x37, 0xe8, 0x6a, 0x63, 0x6a, 0x9f, 0x43, 0x20, 0x95, 0xe1, 0x24, 0xd0, 0x85, 0x12, 0xe2, 0x12,
    0x95, 0x14, 0xaa, 0x0f, 0x6b, 0x05, 0x40, 0x71, 0xbf, 0x63, 0xa5, 0x87, 0xa6, 0x25, 0x70, 0x81,
];

#[allow(dead_code)]
// C745A572-294A-45DF-BF63-E777C8E3AD5B
pub(crate) const TEST_CRED_PIN_ALT: [u8; 16] = [
    0xC7, 0x45, 0xA5, 0x72, 0x29, 0x4A, 0x45, 0xDF, 0xBF, 0x63, 0xE7, 0x77, 0xC8, 0xE3, 0xAD, 0x5B,
];

#[allow(dead_code)]
pub(crate) const MAX_SESSIONS: usize = 8;

#[allow(dead_code)]
pub(crate) const DEFAULT_VAULT_MANAGER_ID: [u8; 16] = [
    0xBC, 0x83, 0x2F, 0x56, 0x3C, 0xAB, 0x4E, 0xE4, 0x8A, 0xAD, 0x37, 0x15, 0x25, 0x07, 0x9C, 0xDB,
];

#[allow(dead_code)]
pub(crate) const DEFAULT_VAULT_MANAGER_PIN: [u8; 16] = [
    0xC8, 0xF8, 0x9F, 0x21, 0xF9, 0x01, 0x42, 0x4A, 0xB9, 0xEB, 0xD2, 0xBC, 0x75, 0x1D, 0x85, 0xB7,
];

#[allow(dead_code)]
pub(crate) const TEST_VAULT_MANAGER_ID: [u8; 16] = [
    0x83, 0x2F, 0x56, 0x3C, 0xAB, 0x4E, 0xE4, 0x8A, 0xAD, 0x37, 0x15, 0x25, 0x07, 0x9C, 0xDB, 0xBC,
];

#[allow(dead_code)]
pub(crate) const TEST_VAULT_MANAGER_PIN: [u8; 16] = [
    0x62, 0x69, 0xf8, 0x77, 0x4f, 0xb6, 0x41, 0x5f, 0xac, 0x82, 0x96, 0x1c, 0xb4, 0x97, 0x1f, 0x66,
];

#[allow(dead_code)]
pub(crate) const DEFAULT_VAULT_ID: [u8; 16] = [
    0xE0, 0x1D, 0x5E, 0xA3, 0x64, 0x51, 0x43, 0x9D, 0xA5, 0x5C, 0x23, 0xDE, 0xD8, 0x56, 0xEF, 0xA3,
];

#[allow(dead_code)]
pub(crate) const APP_ID_FOR_INTERNAL_KEYS: [u8; 16] = [
    0xE0, 0x1D, 0x5E, 0xA3, 0x64, 0x51, 0x43, 0x9D, 0xA5, 0x5C, 0x23, 0xDE, 0xD8, 0x56, 0xEF, 0xA3,
];

#[allow(dead_code)]
pub(crate) const TEST_APP_1_ID: [u8; 16] = [0x1; 16];
#[allow(dead_code)]
pub(crate) const TEST_APP_1_PIN: [u8; 16] = [0x2; 16];

// Vault Manager Session ID
#[allow(dead_code)]
pub const COMMON_SESS_ID1: u16 = 0;

#[allow(dead_code)]
pub(crate) const HARD_CODED_BK3: [u8; 48] = [
    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00,
    0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78, 0x87, 0x96, 0xA5, 0xB4, 0xC3, 0xD2, 0xE1, 0xF0,
];

#[allow(dead_code)]
pub fn common_setup(dev: &mut <DdiTest as Ddi>::Dev, ddi: &DdiTest, path: &str) -> u16 {
    common_cleanup(dev, ddi, path, None);

    let mut setup_dev = ddi.open_dev(path).unwrap();

    // Set Device Kind
    set_device_kind(&mut setup_dev);

    let _ =
        helper_common_establish_credential_no_unwrap(&mut setup_dev, TEST_CRED_ID, TEST_CRED_PIN);

    let (encrypted_credential, pub_key) = encrypt_userid_pin_for_open_session(
        &setup_dev,
        TEST_CRED_ID,
        TEST_CRED_PIN,
        TEST_SESSION_SEED,
    );

    let resp = helper_open_session(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        encrypted_credential,
        pub_key,
    );
    assert!(resp.is_ok(), "resp {:?}", resp);

    let resp = resp.unwrap();

    assert!(resp.hdr.sess_id.is_some());

    resp.hdr.sess_id.unwrap()
}

#[allow(dead_code)]
pub fn common_cleanup(
    dev: &mut <DdiTest as Ddi>::Dev,
    ddi: &DdiTest,
    path: &str,
    session_to_close: Option<u16>,
) {
    // Attempt to close session
    if let Some(session_id) = session_to_close {
        let _resp = helper_close_session(
            dev,
            Some(session_id),
            Some(DdiApiRev { major: 1, minor: 0 }),
        );
    }

    let cleanup_dev = ddi.open_dev(path).unwrap();
    let resp = cleanup_dev.simulate_nssr_after_lm();

    assert!(resp.is_ok(), "resp {:?}", resp);
}

/// Helper function to verify the certificate chain
/// Using OpenSSL
/// Return the public key of the leaf cert (Attestation public key)
/// First element of cert chain should be the root cert
#[allow(dead_code)]
pub fn helper_verify_cert_chain(collaterals: &[Vec<u8>]) -> Result<bool, X509CertificateError> {
    tracing::debug!("Verifying certificate chain");

    // Create a vector of x509Certificate objects from DER encoded certificates from leaf to root
    let certificates = collaterals
        .iter()
        .rev()
        .map(|cert_der| X509Certificate::from_der(cert_der))
        .collect::<Result<Vec<_>, _>>()?;

    tracing::debug!("Successfully parsed {} certificates", certificates.len());

    tracing::debug!("Validating certificate chain");
    let leaf = certificates
        .first()
        .ok_or(X509CertificateError::VerifyError)?;

    leaf.validate_chain(&certificates[1..certificates.len()])
}

#[allow(dead_code)]
pub fn helper_get_partition_id_pub_key(dev: &mut <DdiTest as Ddi>::Dev) -> Vec<u8> {
    let result = helper_get_cert_chain_info(dev);
    assert!(result.is_ok(), "result {:?}", result);
    let resp = result.unwrap();

    let num_certs = resp.data.num_certs;

    // The leaf certificate is the partition ID cert
    let result = helper_get_certificate(dev, num_certs - 1);
    assert!(result.is_ok(), "result {:?}", result);
    let resp = result.unwrap();

    let cert_der = resp.data.certificate.as_slice();

    // Verify the leaf cert with the cert chain to ensure it is valid
    assert!(
        helper_verify_leaf_cert(dev, cert_der).is_ok(),
        "Leaf cert verification failed"
    );

    // Parse the DER certificate
    let x509 = X509Certificate::from_der(cert_der).unwrap();
    x509.get_public_key_der().unwrap()
}

#[allow(dead_code)]
#[cfg(target_os = "linux")]
pub fn helper_key_signature_verification(
    dev: &mut <DdiTest as Ddi>::Dev,
    pub_key_der: &[u8],
    signature: &[u8],
) -> bool {
    let result = EccPublicKey::from_bytes(pub_key_der);
    assert!(result.is_ok(), "result {:?}", result);
    let ecc_pub = result.unwrap();

    let result = ecc_pub.coord_vec();
    assert!(result.is_ok(), "result {:?}", result);
    let (expected_x, expected_y) = result.unwrap();

    // OpenSSL strips leading zeros from X and Y coordinates, so we have to pad them back
    let mut x_array = [0u8; 48];
    let mut y_array = [0u8; 48];
    x_array[48 - expected_x.len()..48].copy_from_slice(&expected_x);
    y_array[48 - expected_y.len()..48].copy_from_slice(&expected_y);

    // flip the endianness to little endian before getting the digest
    x_array.reverse();
    y_array.reverse();

    // create the raw public key by concatenating X and Y
    let raw_pub_key = [x_array.to_vec(), y_array.to_vec()].concat();

    // get the digest of the raw public key
    let digest = crypto_sha384(raw_pub_key.as_slice());
    let digest_len = digest.len();

    // extract the partition ID public key from the certificate
    let part_id_pub_key = helper_get_partition_id_pub_key(dev);

    // verify the signature using the partition ID public key
    let pkey = EccPublicKey::from_bytes(part_id_pub_key.as_slice()).unwrap();
    Verifier::verify(
        &mut EccAlgo::default(),
        &pkey,
        &digest[..digest_len],
        signature,
    )
    .is_ok()
}

#[allow(dead_code)]
pub fn helper_get_cert_chain_info_data(dev: &mut <DdiTest as Ddi>::Dev) -> (u8, [u8; 32]) {
    let result = helper_get_cert_chain_info(dev);
    assert!(result.is_ok(), "result {:?}", result);
    let resp = result.unwrap();
    let num_certs = resp.data.num_certs;
    let thumbprint = resp.data.thumbprint.data_take();

    (num_certs, thumbprint)
}

#[allow(dead_code)]
pub fn helper_verify_leaf_cert(
    dev: &mut <DdiTest as Ddi>::Dev,
    leaf_cert: &[u8],
) -> Result<bool, X509CertificateError> {
    tracing::debug!("Getting certificate chain");
    // Gets the cert chain
    // 1. Gets the number of certs in the cert chain using DDI command GetCertChainInfo command
    // 2. Gets all certs in the cert chain using DDI command GetCertificate where
    //    cert id is 0 to num_certs - 1.
    // 3. Gets the partition id cert using DDI command GetCertificate which is the last cert in the chain

    let result = helper_get_cert_chain_info(dev);
    assert!(result.is_ok(), "result {:?}", result);

    let resp = result.unwrap();
    let num_certs = resp.data.num_certs;

    let mut cert_chain: Vec<Vec<u8>> = Vec::with_capacity(num_certs as usize);
    for i in 0..num_certs - 1 {
        let result = helper_get_certificate(dev, i);
        assert!(result.is_ok(), "result {:?}", result);

        let resp = result.unwrap();
        let der = &resp.data.certificate.as_slice();
        print!("cert DER {:?}", der);

        cert_chain.push(der.to_vec());
    }

    cert_chain.push(leaf_cert.to_vec());

    tracing::debug!(len = cert_chain.len(), "Done getting cert chain");

    helper_verify_cert_chain(&cert_chain)
}

#[allow(dead_code)]
pub fn helper_common_establish_credential_no_unwrap(
    dev: &mut <DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
) -> Result<(), DdiError> {
    // Get establish credential encryption key
    let resp = helper_get_establish_cred_encryption_key(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
    )?;

    // Establish credential
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_establish_credential(id, pin, nonce)
        .unwrap();

    let mut bk3 = vec![0u8; 48];
    Rng::rand_bytes(&mut bk3).unwrap();
    let masked_bk3 = helper_get_or_init_bk3(dev);

    let get_cert_chain_info = helper_get_cert_chain_info(dev).unwrap();
    // Get last cert
    let cert_resp = helper_get_certificate(dev, get_cert_chain_info.data.num_certs - 1).unwrap();
    let cert = cert_resp.data.certificate.as_slice();
    let cert = X509Certificate::from_der(cert).unwrap();
    let cert_pub_key_der = cert.get_public_key_der().unwrap();
    let cert_pub_key_obj = azihsm_crypto::DerEccPublicKey::from_der(&cert_pub_key_der).unwrap();
    let mut cert_pub_key_tbs = vec![0x04u8];
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.x());
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.y());
    let hash_algo = HashAlgo::sha384();
    let mut ecdsa_algo = EcdsaAlgo::new(hash_algo);
    let tpm_priv_key = azihsm_crypto::EccPrivateKey::from_bytes(&TEST_TPM_ECC_PRIVATE_KEY).unwrap();
    let sig_len = Signer::sign(&mut ecdsa_algo, &tpm_priv_key, &cert_pub_key_tbs, None).unwrap();
    let mut signature = vec![0u8; sig_len];
    let _ = Signer::sign(
        &mut ecdsa_algo,
        &tpm_priv_key,
        &cert_pub_key_tbs,
        Some(&mut signature),
    )
    .unwrap();

    let _ = helper_establish_credential(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        ddi_encrypted_credential,
        ddi_public_key,
        masked_bk3,
        MborByteArray::from_slice(&[]).expect("Failed to create empty BMK"),
        MborByteArray::from_slice(&[]).expect("Failed to create empty masked unwrapping key"),
        MborByteArray::from_slice(&signature).expect("Failed to create signed PID"),
        DdiDerPublicKey {
            der: MborByteArray::from_slice(&TEST_TPM_ECC_PUB_KEY)
                .expect("Failed to create MborByteArray from TPM ECC public key"),
            key_kind: DdiKeyType::Ecc384Public,
        },
    )?;

    Ok(())
}

#[allow(dead_code)]
pub fn helper_common_establish_credential_with_bmk(
    dev: &mut <DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
    masked_bk3: MborByteArray<1024>,
    bmk: MborByteArray<1024>,
    unwrapping_key: MborByteArray<1024>,
) -> MborByteArray<1024> {
    // Get establish credential encryption key
    let resp =
        helper_get_establish_cred_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))
            .unwrap();

    // Establish credential
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_establish_credential(id, pin, nonce)
        .unwrap();

    let get_cert_chain_info = helper_get_cert_chain_info(dev).unwrap();
    // Get last cert
    let cert_resp = helper_get_certificate(dev, get_cert_chain_info.data.num_certs - 1).unwrap();
    let cert = cert_resp.data.certificate.as_slice();
    let cert = X509Certificate::from_der(cert).unwrap();
    let cert_pub_key_der = cert.get_public_key_der().unwrap();
    let cert_pub_key_obj = azihsm_crypto::DerEccPublicKey::from_der(&cert_pub_key_der).unwrap();
    let mut cert_pub_key_tbs = vec![0x04u8];
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.x());
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.y());

    let hash_algo = HashAlgo::sha384();
    let mut ecdsa_algo = EcdsaAlgo::new(hash_algo);
    let tpm_priv_key = azihsm_crypto::EccPrivateKey::from_bytes(&TEST_TPM_ECC_PRIVATE_KEY).unwrap();
    let sig_len = Signer::sign(&mut ecdsa_algo, &tpm_priv_key, &cert_pub_key_tbs, None).unwrap();
    let mut signature = vec![0u8; sig_len];
    let _ = Signer::sign(
        &mut ecdsa_algo,
        &tpm_priv_key,
        &cert_pub_key_tbs,
        Some(&mut signature),
    )
    .unwrap();

    let resp = helper_establish_credential(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        ddi_encrypted_credential,
        ddi_public_key,
        masked_bk3,
        bmk,
        unwrapping_key,
        MborByteArray::from_slice(&signature).expect("Failed to create signed PID"),
        DdiDerPublicKey {
            der: MborByteArray::from_slice(&TEST_TPM_ECC_PUB_KEY)
                .expect("Failed to create MborByteArray from TPM ECC public key"),
            key_kind: DdiKeyType::Ecc384Public,
        },
    );

    resp.unwrap().data.bmk
}

#[allow(dead_code)]
pub fn helper_common_establish_credential_with_bmk_no_unwrap(
    dev: &mut <DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
    masked_bk3: MborByteArray<1024>,
    bmk: MborByteArray<1024>,
    unwrapping_key: MborByteArray<1024>,
) -> Result<DdiEstablishCredentialCmdResp, DdiError> {
    // Get establish credential encryption key
    let resp =
        helper_get_establish_cred_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))
            .unwrap();

    // Establish credential
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_establish_credential(id, pin, nonce)
        .unwrap();

    helper_establish_credential(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        ddi_encrypted_credential,
        ddi_public_key,
        masked_bk3,
        bmk,
        unwrapping_key,
        MborByteArray::from_slice(&[]).expect("Failed to create signed PID"),
        DdiDerPublicKey {
            der: MborByteArray::from_slice(&[]).expect("Failed to create empty DER"),
            key_kind: DdiKeyType::Ecc384Public,
        },
    )
}

#[derive(Clone, Copy)]
#[allow(dead_code)]
pub struct LMSetupResult {
    pub session_id: u16,
    pub masked_bk3: MborByteArray<1024>,
    pub partition_bmk: MborByteArray<1024>,
    pub session_bmk: MborByteArray<1024>,
    pub random_seed: [u8; 48],
}

// This setup will use the similar flow of the common_setup but return a collection of re-usable variables for LM purpose
#[allow(dead_code)]
pub fn common_setup_for_lm(
    dev: &mut <DdiTest as Ddi>::Dev,
    ddi: &DdiTest,
    path: &str,
) -> LMSetupResult {
    common_cleanup(dev, ddi, path, None);

    let mut setup_dev = ddi.open_dev(path).unwrap();

    // Set Device Kind
    set_device_kind(&mut setup_dev);

    let masked_bk3 = helper_get_or_init_bk3(&setup_dev);

    let mut random_seed = vec![0u8; 48];
    Rng::rand_bytes(&mut random_seed).unwrap();

    // This is used for initial setup from fresh so all the option fields are empty
    let bmk = helper_common_establish_credential_with_bmk(
        &mut setup_dev,
        TEST_CRED_ID,
        TEST_CRED_PIN,
        masked_bk3,
        MborByteArray::from_slice(&[]).expect("Failed to create empty BMK"),
        MborByteArray::from_slice(&[]).expect("Failed to create empty masked unwrapping key"),
    );

    let (encrypted_credential, pub_key) = encrypt_userid_pin_for_open_session(
        &setup_dev,
        TEST_CRED_ID,
        TEST_CRED_PIN,
        random_seed.as_slice().try_into().unwrap(),
    );

    let resp = helper_open_session(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        encrypted_credential,
        pub_key,
    );
    assert!(resp.is_ok(), "resp {:?}", resp);

    let resp = resp.unwrap();
    assert!(resp.hdr.sess_id.is_some());

    LMSetupResult {
        session_id: resp.hdr.sess_id.unwrap(),
        masked_bk3,
        partition_bmk: bmk,
        session_bmk: resp.data.bmk_session,
        random_seed: random_seed.as_slice().try_into().unwrap(),
    }
}

#[allow(dead_code)]
pub fn helper_common_establish_credential(
    dev: &mut <DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
) {
    // Get establish credential encryption key

    let resp =
        helper_get_establish_cred_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }));

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();

    // Establish credential
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_establish_credential(id, pin, nonce)
        .unwrap();

    let masked_bk3 = helper_get_or_init_bk3(dev);

    let get_cert_chain_info = helper_get_cert_chain_info(dev).unwrap();
    // Get last cert
    let cert_resp = helper_get_certificate(dev, get_cert_chain_info.data.num_certs - 1).unwrap();
    let cert = cert_resp.data.certificate.as_slice();
    let cert = X509Certificate::from_der(cert).unwrap();
    let cert_pub_key_der = cert.get_public_key_der().unwrap();
    let cert_pub_key_obj = azihsm_crypto::DerEccPublicKey::from_der(&cert_pub_key_der).unwrap();
    let mut cert_pub_key_tbs = vec![0x04u8];
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.x());
    cert_pub_key_tbs.extend_from_slice(&cert_pub_key_obj.y());

    let hash_algo = HashAlgo::sha384();
    let mut ecdsa_algo = EcdsaAlgo::new(hash_algo);
    let tpm_priv_key = azihsm_crypto::EccPrivateKey::from_bytes(&TEST_TPM_ECC_PRIVATE_KEY).unwrap();
    let sig_len = Signer::sign(&mut ecdsa_algo, &tpm_priv_key, &cert_pub_key_tbs, None).unwrap();
    let mut signature = vec![0u8; sig_len];
    let _ = Signer::sign(
        &mut ecdsa_algo,
        &tpm_priv_key,
        &cert_pub_key_tbs,
        Some(&mut signature),
    )
    .unwrap();

    let resp = helper_establish_credential(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        ddi_encrypted_credential,
        ddi_public_key,
        masked_bk3,
        MborByteArray::from_slice(&[]).expect("Failed to create empty BMK"),
        MborByteArray::from_slice(&[]).expect("Failed to create empty masked unwrapping key"),
        MborByteArray::from_slice(&signature).expect("Failed to create signed PID"),
        DdiDerPublicKey {
            der: MborByteArray::from_slice(&TEST_TPM_ECC_PUB_KEY)
                .expect("Failed to create MborByteArray from TPM ECC public key"),
            key_kind: DdiKeyType::Ecc384Public,
        },
    );
    assert!(resp.is_ok(), "resp {:?}", resp);
    resp.unwrap();
}

#[allow(unused)]
pub fn get_device_info(ddi: &DdiTest, path: &str) -> DdiGetDeviceInfoResp {
    let dev = open_dev_and_set_device_kind(ddi, path);
    let resp = helper_get_device_info(&dev, None, Some(DdiApiRev { major: 1, minor: 0 }));

    assert!(resp.is_ok(), "resp {:?}", resp);

    let resp = resp.unwrap();

    resp.data
}

#[allow(unused)]
pub fn get_device_kind(dev: &mut <DdiTest as Ddi>::Dev) -> DdiDeviceKind {
    let resp = helper_get_device_info(dev, None, Some(DdiApiRev { major: 1, minor: 0 })).unwrap();

    resp.data.kind
}

#[allow(unused)]
pub fn set_device_kind(dev: &mut <DdiTest as Ddi>::Dev) {
    let result = get_device_kind(dev);

    dev.set_device_kind(result);
}

#[allow(unused)]
pub fn encrypt_userid_pin_for_establish_cred(
    dev: &<DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
) -> (DdiEncryptedEstablishCredential, DdiDerPublicKey) {
    let resp =
        helper_get_establish_cred_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))
            .unwrap();
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_establish_credential(id, pin, nonce)
        .unwrap();

    (ddi_encrypted_credential, ddi_public_key)
}

#[allow(unused)]
pub fn encrypt_userid_pin_for_open_session(
    dev: &<DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
    seed: [u8; 48],
) -> (DdiEncryptedSessionCredential, DdiDerPublicKey) {
    let resp = helper_get_session_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))
        .unwrap();
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_session_credential(id, pin, seed, nonce)
        .unwrap();

    (ddi_encrypted_credential, ddi_public_key)
}

#[allow(unused)]
pub fn encrypt_userid_pin_for_open_session_no_unwrap(
    dev: &<DdiTest as Ddi>::Dev,
    id: [u8; 16],
    pin: [u8; 16],
    seed: [u8; 48],
) -> Result<(DdiEncryptedSessionCredential, DdiDerPublicKey), Box<dyn std::error::Error>> {
    let resp =
        helper_get_session_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))?;
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce)?;
    let (establish_cred_encryption_key, ddi_public_key) =
        param_encryption_key.create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)?;
    let ddi_encrypted_credential =
        establish_cred_encryption_key.encrypt_session_credential(id, pin, seed, nonce)?;

    Ok((ddi_encrypted_credential, ddi_public_key))
}

#[allow(unused)]
pub fn encrypt_pin_for_change_pin(
    dev: &<DdiTest as Ddi>::Dev,
    pin: [u8; 16],
) -> (DdiEncryptedPin, DdiDerPublicKey) {
    let resp = helper_get_session_encryption_key(dev, None, Some(DdiApiRev { major: 1, minor: 0 }))
        .unwrap();
    let nonce = resp.data.nonce;
    let param_encryption_key = DeviceCredKey::new(&resp.data.pub_key, nonce).unwrap();
    let (establish_cred_encryption_key, ddi_public_key) = param_encryption_key
        .create_credential_key_from_der(&TEST_ECC_384_PRIVATE_KEY)
        .unwrap();
    let ddi_encrypted_credential = establish_cred_encryption_key
        .encrypt_pin(pin, nonce)
        .unwrap();

    (ddi_encrypted_credential, ddi_public_key)
}

#[allow(unused)]
pub fn store_rsa_keys_no_crt(
    dev: &mut <DdiTest as Ddi>::Dev,
    sess_id: u16,
    key_usage: DdiKeyUsage,
    rsa_key_size_in_k: u8,
    key_tag: Option<u16>,
) -> (DdiDerPublicKey, u16, MborByteArray<3072>) {
    let rsa_priv_key = if rsa_key_size_in_k == 2 {
        TEST_RSA_2K_PRIVATE_KEY.as_slice()
    } else if rsa_key_size_in_k == 3 {
        TEST_RSA_3K_PRIVATE_KEY.as_slice()
    } else if rsa_key_size_in_k == 4 {
        TEST_RSA_4K_PRIVATE_KEY.as_slice()
    } else {
        panic!("Invalid RSA key size");
    };

    let resp = rsa_secure_import_key(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        rsa_priv_key,
        DdiKeyClass::Rsa,
        key_usage,
        key_tag,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);

    let resp = resp.unwrap();

    let key_id_rsa_priv = resp.data.key_id;
    let key_rsa_pub = resp.data.pub_key.unwrap();

    (key_rsa_pub, key_id_rsa_priv, resp.data.masked_key)
}

#[allow(unused)]
pub fn store_rsa_keys_crt(
    dev: &mut <DdiTest as Ddi>::Dev,
    sess_id: u16,
    key_usage: DdiKeyUsage,
    rsa_key_size_in_k: u8,
    key_tag: Option<u16>,
) -> (DdiDerPublicKey, u16, MborByteArray<3072>) {
    let rsa_priv_key = if rsa_key_size_in_k == 2 {
        TEST_RSA_2K_PRIVATE_KEY.as_slice()
    } else if rsa_key_size_in_k == 3 {
        TEST_RSA_3K_PRIVATE_KEY.as_slice()
    } else if rsa_key_size_in_k == 4 {
        TEST_RSA_4K_PRIVATE_KEY.as_slice()
    } else {
        panic!("Invalid RSA key size");
    };

    let resp = rsa_secure_import_key(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        rsa_priv_key,
        DdiKeyClass::Rsa,
        key_usage,
        key_tag,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);

    let resp = resp.unwrap();

    let key_id_rsa_priv_crt = resp.data.key_id;
    let key_rsa_pub = resp.data.pub_key.unwrap();

    (key_rsa_pub, key_id_rsa_priv_crt, resp.data.masked_key)
}

#[allow(dead_code)]
pub fn store_aes_keys(dev: &mut <DdiTest as Ddi>::Dev, sess_id: u16) -> u16 {
    let resp = rsa_secure_import_key(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        &TEST_AES_256,
        DdiKeyClass::Aes,
        DdiKeyUsage::EncryptDecrypt,
        None,
    );
    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();

    resp.data.key_id
}

/// Helper to perform the ECC gen-key command execution using mcr device.
#[allow(unused)]
pub fn ecc_gen_key_mcr(
    dev: &mut <DdiTest as Ddi>::Dev,
    curve: DdiEccCurve,
    key_tag: Option<u16>,
    session_id: Option<u16>,
    key_usage: DdiKeyUsage,
) -> (u16, DdiDerPublicKey, MborByteArray<3072>) {
    let key_props = helper_key_properties(key_usage, DdiKeyAvailability::App);

    let resp = helper_ecc_generate_key_pair(
        dev,
        session_id,
        Some(DdiApiRev { major: 1, minor: 0 }),
        curve,
        key_tag,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();

    (
        resp.data.private_key_id,
        resp.data.pub_key,
        resp.data.masked_key,
    )
}

/// Helper to perform the get unwrapping command execution using mcr device.
#[allow(unused)]
pub fn get_unwrapping_key(
    dev: &mut <DdiTest as Ddi>::Dev,
    sess_id: u16,
) -> (u16, Vec<u8>, MborByteArray<1024>) {
    // If key is not found, re-check for key once every 5 seconds for up to 30 minutes.
    let mut timeout_s = 30 * 60;
    let interval_s = 5;
    loop {
        assert!(timeout_s > 0, "Unwrapping key generation took too long");

        let resp =
            helper_get_unwrapping_key(dev, Some(sess_id), Some(DdiApiRev { major: 1, minor: 0 }));

        if let Err(err) = resp {
            assert!(
                matches!(err, DdiError::DdiStatus(DdiStatus::PendingKeyGeneration)),
                "{:?}",
                err
            );

            thread::sleep(std::time::Duration::from_secs(interval_s));
            timeout_s -= interval_s;
            println!(
                "Awaiting unwrapping key generation, will retry after {} seconds",
                interval_s
            );
            continue;
        }
        assert!(resp.is_ok(), "resp {:?}", resp);
        let resp = resp.unwrap();
        assert!(!resp.data.masked_key.is_empty());

        return (
            resp.data.key_id,
            resp.data.pub_key.der.as_slice().to_vec(),
            resp.data.masked_key,
        );
    }
}

/// Helper to wrap a data using wrapping key and AES key
#[allow(unused)]
pub fn wrap_data_with_aes_key(
    wrapping_pub_key_der: Vec<u8>,
    data: &[u8],
    aes_key: &[u8],
) -> Vec<u8> {
    let wrapping_pub_key = RsaPublicKey::from_bytes(&wrapping_pub_key_der).unwrap();

    let mut encrypted_aes_key = Encrypter::encrypt_vec(
        &mut RsaEncryptAlgo::with_oaep_padding(HashAlgo::sha256(), None),
        &wrapping_pub_key,
        aes_key,
    )
    .unwrap();

    let aes_key = AesKey::from_bytes(aes_key).expect("Failed to create AES key");

    let mut encrypted_data =
        Encrypter::encrypt_vec(&mut AesKeyWrapPadAlgo::default(), &aes_key, data)
            .expect("Failed to wrap data");

    // Concatenate the encrypted_aes_key and encrypted_data to form the wrapped blob
    let mut wrapped_data = Vec::with_capacity(encrypted_aes_key.len() + encrypted_data.len());
    wrapped_data.append(&mut encrypted_aes_key);
    wrapped_data.append(&mut encrypted_data);

    wrapped_data
}

/// Helper to wrap a data using wrapping key
#[allow(unused)]
pub fn wrap_data(wrapping_pub_key_der: Vec<u8>, data: &[u8]) -> Vec<u8> {
    let aes_key = TEST_EPHEMERAL_AES.as_slice();
    let wrapping_pub_key = RsaPublicKey::from_bytes(&wrapping_pub_key_der).unwrap();
    let mut encrypted_aes_key = Encrypter::encrypt_vec(
        &mut RsaEncryptAlgo::with_oaep_padding(HashAlgo::sha256(), None),
        &wrapping_pub_key,
        aes_key,
    )
    .unwrap();

    let aes_key = AesKey::from_bytes(aes_key).expect("Failed to create AES key");

    let mut encrypted_data =
        Encrypter::encrypt_vec(&mut AesKeyWrapPadAlgo::default(), &aes_key, data)
            .expect("Failed to wrap data");

    // Concatenate the encrypted_aes_key and encrypted_data to form the wrapped blob
    let mut wrapped_data = Vec::with_capacity(encrypted_aes_key.len() + encrypted_data.len());
    wrapped_data.append(&mut encrypted_aes_key);
    wrapped_data.append(&mut encrypted_data);

    wrapped_data
}

/// Helper to perform ECC signing operation using OpenSSL/Symcrypt.
#[allow(unused)]
pub fn ecc_sign_local(
    priv_key: Vec<u8>,
    curve: EccCurve,
    digest: [u8; 96],
    digest_len: usize,
) -> Vec<u8> {
    let der = DerEccPrivateKey::new(curve, &priv_key);
    let vec = der.to_der_vec().unwrap();
    let pkey = EccPrivateKey::from_bytes(&vec).unwrap();
    Signer::sign_vec(&mut EccAlgo::default(), &pkey, &digest[..digest_len]).unwrap()
}

/// Helper to perform ECC verify operation using OpenSSL.
#[allow(unused)]
pub fn ecc_verify_local_openssl(
    signature: &[u8],
    pub_key: &DdiDerPublicKey,
    digest: [u8; 96],
    digest_len: usize,
) -> bool {
    let pkey = EccPublicKey::from_bytes(&pub_key.der.data()[..pub_key.der.len()]).unwrap();
    Verifier::verify(
        &mut EccAlgo::default(),
        &pkey,
        &digest[..digest_len],
        signature,
    )
    .unwrap()
}

// Helper to perform RSA encrypt operation using OpenSSL.
#[allow(dead_code)]
pub fn rsa_encrypt_local_openssl(
    pub_key: &[u8],
    x: &[u8],
    x_len: usize,
    padding: DdiRsaCryptoPadding,
    hash_algorithm: Option<DdiHashAlgorithm>,
) -> Vec<u8> {
    if padding != DdiRsaCryptoPadding::Oaep {
        return vec![];
    }

    let hash = hash_algorithm
        .map(|x| match x {
            DdiHashAlgorithm::Sha1 => HashAlgo::sha1(),
            DdiHashAlgorithm::Sha256 => HashAlgo::sha256(),
            DdiHashAlgorithm::Sha384 => HashAlgo::sha384(),
            DdiHashAlgorithm::Sha512 => HashAlgo::sha512(),
            _ => panic!("Unsupported hash algorithm"),
        })
        .unwrap_or(HashAlgo::sha1());

    let pkey = RsaPublicKey::from_bytes(pub_key).unwrap();
    Encrypter::encrypt_vec(
        &mut RsaEncryptAlgo::with_oaep_padding(hash, None),
        &pkey,
        &x[..x_len],
    )
    .unwrap()
}

#[allow(dead_code)]
pub fn rsa_verify_local_openssl(
    pub_key: &[u8],
    signature: &[u8],
    digest: &[u8],
    pkcs1: bool,
    hash_algorithm: Option<DdiHashAlgorithm>,
    salt_len: Option<u16>,
) -> bool {
    let hash = hash_algorithm
        .map(|x| match x {
            DdiHashAlgorithm::Sha1 => HashAlgo::sha1(),
            DdiHashAlgorithm::Sha256 => HashAlgo::sha256(),
            DdiHashAlgorithm::Sha384 => HashAlgo::sha384(),
            DdiHashAlgorithm::Sha512 => HashAlgo::sha512(),
            _ => panic!("Unsupported hash algorithm"),
        })
        .unwrap_or(HashAlgo::sha1());

    let pkey = RsaPublicKey::from_bytes(pub_key).unwrap();

    let mut algo = if pkcs1 {
        RsaSignAlgo::with_pkcs1_padding(hash)
    } else {
        RsaSignAlgo::with_pss_padding(hash, salt_len.unwrap_or(20) as usize)
    };

    Verifier::verify(&mut algo, &pkey, digest, signature).is_ok()
}

// Returns: secret key id 1, secret key id 2
#[allow(dead_code)]
pub fn create_ecdh_secrets(
    sess_id: u16,
    dev: &mut <DdiTest as Ddi>::Dev,
    secret_key_type: DdiKeyType,
) -> (u16, u16) {
    // Check secret key type. If it's not a secret key, we will use DdiKeyType::Secret256.
    let (secret_key_type, curve) = match secret_key_type {
        DdiKeyType::Secret256 => (DdiKeyType::Secret256, DdiEccCurve::P256),
        DdiKeyType::Secret384 => (DdiKeyType::Secret384, DdiEccCurve::P384),
        DdiKeyType::Secret521 => (DdiKeyType::Secret521, DdiEccCurve::P521),
        _ => (DdiKeyType::Secret256, DdiEccCurve::P256),
    };

    // Generate ECC Key Pair 1

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);

    let resp = helper_ecc_generate_key_pair(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        curve,
        None,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();
    let private_key_id1 = resp.data.private_key_id;

    let pub_key1 = resp.data.pub_key;
    let mut der1 = [0u8; 192];
    der1[..pub_key1.der.len()].clone_from_slice(&pub_key1.der.data()[..pub_key1.der.len()]);

    // Generate ECC Key Pair 2

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);

    let resp = helper_ecc_generate_key_pair(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        curve,
        None,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();

    let private_key_id2 = resp.data.private_key_id;

    let pub_key2 = resp.data.pub_key;
    let mut der2 = [0u8; 192];
    der2[..pub_key2.der.len()].clone_from_slice(&pub_key2.der.data()[..pub_key2.der.len()]);

    // Perform Ecdh exchange for each pair
    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);
    let resp = helper_ecdh_key_exchange(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        private_key_id1,
        MborByteArray::new(der2, pub_key2.der.len()).expect("failed to create byte array"),
        None,
        secret_key_type,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let secret_key_id1 = resp.unwrap().data.key_id;

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);
    let resp = helper_ecdh_key_exchange(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        private_key_id2,
        MborByteArray::new(der1, pub_key1.der.len()).expect("failed to create byte array"),
        None,
        secret_key_type,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let secret_key_id2 = resp.unwrap().data.key_id;

    (secret_key_id1, secret_key_id2)
}

// Uses Ecc generate, ECDH, KDF to create an HMAC key
#[allow(dead_code)]
pub fn create_hmac_key_ex(
    sess_id: u16,
    target_key_type: DdiKeyType,
    dev: &mut <DdiTest as Ddi>::Dev,
    target_key_len: Option<u8>,
) -> Result<DdiHkdfDeriveCmdResp, DdiError> {
    // Generate ECC Key Pair 1

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);

    let resp = helper_ecc_generate_key_pair(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        DdiEccCurve::P256,
        None,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();
    let private_key_id1 = resp.data.private_key_id;

    // Generate ECC Key Pair 2

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);

    let resp = helper_ecc_generate_key_pair(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        DdiEccCurve::P256,
        None,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let resp = resp.unwrap();

    let pub_key2 = resp.data.pub_key;
    let mut der2 = [0u8; 192];
    der2[..pub_key2.der.len()].clone_from_slice(&pub_key2.der.data()[..pub_key2.der.len()]);

    // Perform Ecdh exchange for private key 1, public key 2

    let key_props = helper_key_properties(DdiKeyUsage::Derive, DdiKeyAvailability::App);
    let resp = helper_ecdh_key_exchange(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        private_key_id1,
        MborByteArray::new(der2, pub_key2.der.len()).expect("failed to create byte array"),
        None,
        DdiKeyType::Secret256,
        key_props,
    );

    assert!(resp.is_ok(), "resp {:?}", resp);
    let secret_key_id1 = resp.unwrap().data.key_id;

    // Use HKDF to derive HMAC key
    let key_props = helper_key_properties(DdiKeyUsage::SignVerify, DdiKeyAvailability::Session);

    helper_hkdf_derive(
        dev,
        Some(sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        secret_key_id1,
        DdiHashAlgorithm::Sha256,
        None,
        None,
        target_key_type,
        None,
        key_props,
        target_key_len,
    )
}

// Uses Ecc generate, ECDH, KDF to create an HMAC key
#[allow(dead_code)]
pub fn create_hmac_key(
    sess_id: u16,
    target_key_type: DdiKeyType,
    dev: &mut <DdiTest as Ddi>::Dev,
    target_key_len: Option<u8>,
) -> u16 {
    let resp = create_hmac_key_ex(sess_id, target_key_type, dev, target_key_len);

    assert!(resp.is_ok(), "resp {:?}", resp);
    resp.unwrap().data.key_id
}

#[allow(unused)]
pub fn generate_aes_bulk_256_key(
    dev: &<DdiTest as Ddi>::Dev,
    app_sess_id: &u16,
    key_tag: Option<u16>,
    aes_key_size: DdiAesKeySize,
) -> Result<DdiAesGenerateKeyCmdResp, DdiError> {
    // generate AES 256 bulk key
    let key_props = helper_key_properties(DdiKeyUsage::EncryptDecrypt, DdiKeyAvailability::App);

    if !aes_key_size.is_bulk_key() {
        panic!("aes_key_size is not a bulk key size");
    }

    helper_aes_generate(
        dev,
        Some(*app_sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
        aes_key_size,
        key_tag,
        key_props,
    )
}

/// Helper to close the session.
#[allow(unused)]
pub fn close_app_session(dev: &mut <DdiTest as Ddi>::Dev, app_sess_id: u16) {
    // Create the close session request
    let resp = helper_close_session(
        dev,
        Some(app_sess_id),
        Some(DdiApiRev { major: 1, minor: 0 }),
    );
    assert!(
        resp.is_ok(),
        "Failed to close session with ID {}: {:?}",
        app_sess_id,
        resp
    );
}

/// Helper to reopen the session and fetch `short_app_id`.
#[allow(unused)]
pub fn reopen_session_with_short_app_id(
    dev: &mut <DdiTest as Ddi>::Dev,
    session_id: u16,
) -> (u16, u8) {
    close_app_session(dev, session_id);

    set_device_kind(dev);

    let (encrypted_credential, pub_key) =
        encrypt_userid_pin_for_open_session(dev, TEST_CRED_ID, TEST_CRED_PIN, TEST_SESSION_SEED);

    let resp = helper_open_session(
        dev,
        None,
        Some(DdiApiRev { major: 1, minor: 0 }),
        encrypted_credential,
        pub_key,
    );
    assert!(resp.is_ok(), "Failed to reopen session: {:?}", resp);
    let resp = resp.unwrap();

    (resp.data.sess_id, resp.data.short_app_id)
}

#[allow(dead_code)]
pub fn crypto_sha1(data: &[u8]) -> Vec<u8> {
    Hasher::hash_vec(&mut HashAlgo::sha1(), data).expect("Failed to compute SHA1 hash")
}

#[allow(dead_code)]
pub fn crypto_sha256(data: &[u8]) -> Vec<u8> {
    Hasher::hash_vec(&mut HashAlgo::sha256(), data).expect("Failed to compute SHA256 hash")
}

#[allow(dead_code)]
pub fn crypto_sha384(data: &[u8]) -> Vec<u8> {
    Hasher::hash_vec(&mut HashAlgo::sha384(), data).expect("Failed to compute SHA384 hash")
}

#[allow(dead_code)]
pub fn crypto_sha512(data: &[u8]) -> Vec<u8> {
    Hasher::hash_vec(&mut HashAlgo::sha512(), data).expect("Failed to compute SHA512 hash")
}

/// RSA digest kinds for padding operations
#[allow(dead_code)]
pub enum RsaDigestKind {
    Sha1,
    Sha256,
    Sha384,
    Sha512,
}

/// RSA encoding helper functions
#[allow(dead_code)]
pub struct RsaEncoding;

impl RsaEncoding {
    /// Encode data using PKCS#1 v1.5 padding for signatures
    #[allow(dead_code)]
    pub fn encode_pkcs_v15(
        hash: &[u8],
        modulus_size_bytes: usize,
        digest_kind: RsaDigestKind,
    ) -> Result<Vec<u8>, CryptoError> {
        let hash_algo = match digest_kind {
            RsaDigestKind::Sha1 => HashAlgo::sha1(),
            RsaDigestKind::Sha256 => HashAlgo::sha256(),
            RsaDigestKind::Sha384 => HashAlgo::sha384(),
            RsaDigestKind::Sha512 => HashAlgo::sha512(),
        };

        let mut algo = RsaPadPkcs1SignAlgo::new(modulus_size_bytes, hash_algo, hash);
        Encoder::encode_vec(&mut algo)
    }

    /// Encode data using PSS padding for signatures  
    #[allow(dead_code)]
    pub fn encode_pss<F>(
        hash: &[u8],
        mod_bits: usize,
        digest_kind: RsaDigestKind,
        _hash_fn: fn(&[u8]) -> Vec<u8>,
        salt_length: usize,
        _rng: F,
    ) -> Result<Vec<u8>, CryptoError>
    where
        F: FnMut(&mut [u8]) -> Result<(), ()>,
    {
        let hash_algo = match digest_kind {
            RsaDigestKind::Sha1 => HashAlgo::sha1(),
            RsaDigestKind::Sha256 => HashAlgo::sha256(),
            RsaDigestKind::Sha384 => HashAlgo::sha384(),
            RsaDigestKind::Sha512 => HashAlgo::sha512(),
        };

        let modulus_size_bytes = mod_bits.div_ceil(8);
        let mut algo = RsaPadPssAlgo::with_mgf1(modulus_size_bytes, hash_algo, hash, salt_length);
        Encoder::encode_vec(&mut algo)
    }

    /// Decode OAEP padded data
    #[allow(dead_code)]
    pub fn decode_oaep(
        padded_data: &mut [u8],
        label: Option<&[u8]>,
        modulus_size_bytes: usize,
        digest_kind: RsaDigestKind,
        _hash_fn: fn(&[u8]) -> Vec<u8>,
    ) -> Result<Vec<u8>, CryptoError> {
        let hash_algo = match digest_kind {
            RsaDigestKind::Sha1 => HashAlgo::sha1(),
            RsaDigestKind::Sha256 => HashAlgo::sha256(),
            RsaDigestKind::Sha384 => HashAlgo::sha384(),
            RsaDigestKind::Sha512 => HashAlgo::sha512(),
        };

        // Create OAEP params
        let params = RsaPadOaepAlgoParams::new(modulus_size_bytes, hash_algo, label);

        // Decode OAEP and extract message
        let algo = Decoder::decode::<RsaPadOaepAlgo>(padded_data, params)?;

        // Return the extracted message
        Ok(algo.message().to_vec())
    }
}

/// Helper to check if the error is due to unsupported command.
#[allow(dead_code)]
pub fn is_unsupported_cmd(err: &DdiError) -> bool {
    if let DdiError::DdiStatus(DdiStatus::UnsupportedCmd) = err {
        println!("Firmware is not built with fips_validation_hooks.");
        true
    } else {
        false
    }
}

/// Helper to check if firmware was not build with mcr_test_hooks
#[allow(dead_code)]
pub fn firmware_not_built_with_test_hooks(err: &DdiError) -> bool {
    if let DdiError::DdiStatus(DdiStatus::UnsupportedCmd) = err {
        println!("Firmware is not built with mcr_test_hooks.");
        true
    } else {
        false
    }
}

// Keys to import have to be in DER PKCS#8 format.
// TEST RSA KEY GENERATE STEPS:
// openssl genrsa -out rsa2k.pem 2048
// openssl rsa -in rsa2k.pem -pubout -outform DER -out public2k.der
// openssl rsa -in rsa2k.pem -outform DER -out private2k.der
//
// TEST RSA KEY ARRAY CONVERSION STEPS:
// xxd -i public2k.der
// xxd -i private2k.der
//
// TEST RSA OPERATIONS STEPS:
// perl -e 'print "\x01" x 256' > data.bin
// openssl pkeyutl -encrypt -in data.bin -out enc2k.bin -inkey public2k.der -pubin \
// -pkeyopt rsa_padding_mode:none
// openssl pkeyutl -decrypt -in data.bin -out dec2k.bin -inkey private2k.der \
// -pkeyopt rsa_padding_mode:none
//
// EXPECTED OUTPUT CONVERSION STEPS:
// xxd -i enc2k.bin
// xxd -i dec2k.bin
//

#[allow(dead_code)]
pub(crate) const TEST_RSA_2K_PRIVATE_KEY: [u8; 1214] = [
    0x30, 0x82, 0x04, 0xba, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x04, 0xa4, 0x30, 0x82, 0x04, 0xa0, 0x02, 0x01,
    0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xe1, 0x60, 0x77, 0xe2, 0x62, 0x3f, 0x84, 0x56, 0xc9, 0x2a,
    0xc1, 0xf2, 0x09, 0x9e, 0x97, 0x22, 0x88, 0x68, 0x47, 0xa4, 0x94, 0x35, 0x6e, 0x81, 0x85, 0xc6,
    0xe6, 0x1e, 0xa8, 0x59, 0xb8, 0x69, 0x6f, 0xfe, 0x29, 0x31, 0x96, 0xac, 0x68, 0x8a, 0x09, 0x39,
    0x3b, 0x89, 0x9b, 0x96, 0xbf, 0x8f, 0x23, 0x12, 0x61, 0xbf, 0x46, 0x69, 0x6d, 0x67, 0x28, 0x56,
    0xab, 0xdf, 0x41, 0xc9, 0x5e, 0x80, 0x0b, 0x73, 0xac, 0xbe, 0x50, 0x08, 0xe0, 0x29, 0x12, 0x71,
    0xce, 0xd0, 0x8e, 0xff, 0x3e, 0x90, 0x3d, 0x5a, 0xcc, 0x14, 0x7f, 0xa9, 0xf0, 0x68, 0xdc, 0x1c,
    0xd8, 0xaf, 0x64, 0xcc, 0x0b, 0x43, 0xb1, 0xa9, 0x3d, 0xfb, 0xe8, 0xbc, 0x90, 0x1a, 0x45, 0xd2,
    0xdb, 0x17, 0xf5, 0x7a, 0xb5, 0xb3, 0x9e, 0x64, 0x31, 0xa5, 0x43, 0xb7, 0x94, 0xa7, 0x31, 0x29,
    0x79, 0x41, 0x69, 0x14, 0xdd, 0x6d, 0x67, 0x68, 0x0a, 0x36, 0x38, 0x0e, 0x35, 0xc6, 0x62, 0xcf,
    0x38, 0xcc, 0x52, 0x64, 0x8d, 0xa6, 0x7e, 0x7e, 0x70, 0x60, 0x46, 0x29, 0x68, 0x3c, 0x42, 0x2e,
    0xe2, 0xd8, 0x21, 0x6d, 0x01, 0x65, 0xc5, 0x86, 0x36, 0xeb, 0x0f, 0x1e, 0x6d, 0xf1, 0xd8, 0x7b,
    0xe0, 0x4d, 0xce, 0x71, 0xc8, 0x35, 0x5c, 0x6f, 0x0c, 0x4a, 0x8b, 0xf8, 0x07, 0x23, 0x6b, 0xfe,
    0x47, 0xdc, 0xbd, 0x02, 0xf2, 0xff, 0xb0, 0xdf, 0xcf, 0x02, 0xf6, 0xa1, 0x4b, 0x6b, 0x99, 0xcc,
    0xc6, 0x76, 0x30, 0xc5, 0xe4, 0x02, 0xf4, 0xa2, 0x02, 0xbf, 0x71, 0x31, 0x3d, 0x80, 0x70, 0x60,
    0x23, 0x12, 0xad, 0x2f, 0x02, 0x20, 0x42, 0x67, 0x15, 0x7a, 0x6d, 0xf4, 0x58, 0x2a, 0x8a, 0x1d,
    0x25, 0x1d, 0xfd, 0x01, 0x3f, 0x83, 0x5f, 0x5a, 0xfb, 0x11, 0x98, 0xda, 0x55, 0x96, 0x8f, 0x26,
    0x61, 0x25, 0x8b, 0xdb, 0xfc, 0xc9, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x81, 0xff, 0x7b, 0x8b,
    0x66, 0x2c, 0x5d, 0xaf, 0x1e, 0x87, 0x1f, 0x14, 0xa6, 0x91, 0xb2, 0x09, 0x92, 0xcf, 0xb0, 0xa1,
    0x79, 0x4f, 0x13, 0xef, 0x8b, 0xa4, 0x1f, 0x5b, 0xe8, 0xc9, 0x90, 0x2a, 0x49, 0x42, 0x2d, 0xcc,
    0xd0, 0x1d, 0x5e, 0xd0, 0x79, 0x28, 0x87, 0x3b, 0x2d, 0xbd, 0x41, 0x37, 0xb7, 0x1f, 0xbf, 0xc4,
    0xa9, 0x25, 0xdb, 0xc8, 0x99, 0xda, 0xf2, 0x97, 0x3a, 0xf5, 0x7c, 0xc5, 0x3b, 0x5d, 0xa0, 0x3e,
    0xc8, 0xc8, 0x35, 0x17, 0x53, 0x1f, 0x30, 0xa7, 0xdd, 0x0c, 0x76, 0xac, 0x1f, 0x4a, 0x47, 0xad,
    0x28, 0xdc, 0xbe, 0x74, 0x14, 0x55, 0x66, 0xfe, 0x69, 0x1f, 0x11, 0xcc, 0xc8, 0x5f, 0xfe, 0x03,
    0xc8, 0x4b, 0xf9, 0x9e, 0x0e, 0xb5, 0xad, 0x90, 0xe8, 0x89, 0x39, 0xb2, 0x5f, 0xe8, 0x6b, 0xeb,
    0x2b, 0x4b, 0xc2, 0x28, 0x8a, 0xff, 0x1b, 0x9e, 0xa0, 0x84, 0x3a, 0xc0, 0xdf, 0xf5, 0x11, 0x6e,
    0xa5, 0x93, 0xd3, 0x05, 0x13, 0x6b, 0x98, 0x70, 0x1d, 0xa8, 0x8d, 0xda, 0x2d, 0xcd, 0xcb, 0x11,
    0x48, 0x59, 0xf4, 0xaa, 0xa9, 0x8a, 0xb0, 0x8a, 0xf4, 0x8d, 0xb4, 0x00, 0x35, 0x9f, 0x2b, 0x44,
    0x99, 0x06, 0x41, 0x99, 0xcb, 0xe4, 0x24, 0xc1, 0xfa, 0xb4, 0x2b, 0x42, 0xc7, 0xbe, 0x50, 0xd1,
    0xca, 0x16, 0xed, 0x69, 0x68, 0xfe, 0xcc, 0x13, 0xd0, 0x6b, 0x8c, 0xa2, 0xfd, 0x97, 0x37, 0xf4,
    0xdc, 0x2b, 0x59, 0x63, 0xf0, 0x4f, 0x15, 0x1e, 0x6d, 0x4a, 0xed, 0x16, 0x4f, 0xff, 0xc8, 0x73,
    0x79, 0x8f, 0x4c, 0x3f, 0x29, 0xfa, 0x00, 0x8d, 0xc1, 0xf2, 0xe9, 0x32, 0x46, 0xae, 0x68, 0x9d,
    0x64, 0xe1, 0xbe, 0x0e, 0x3d, 0xad, 0x31, 0xa4, 0x1f, 0x16, 0x58, 0x73, 0x5d, 0x89, 0x70, 0xd9,
    0xdb, 0xf4, 0x91, 0xab, 0x6d, 0x71, 0xf0, 0x2b, 0x8d, 0xf9, 0x59, 0xd7, 0x1d, 0x02, 0x81, 0x81,
    0x00, 0xfb, 0x9c, 0x2b, 0xde, 0xb2, 0xda, 0x0d, 0xc7, 0x16, 0xd4, 0x69, 0xb7, 0xca, 0xb1, 0x2d,
    0x3d, 0x4b, 0xd0, 0x4a, 0x9c, 0xbb, 0xc6, 0x99, 0x7d, 0xfe, 0x50, 0xb2, 0xde, 0x84, 0x64, 0xef,
    0xbd, 0xf8, 0x72, 0x9e, 0x55, 0x4e, 0xb6, 0xa6, 0xa1, 0x68, 0x47, 0xb0, 0x69, 0x77, 0x1a, 0x7b,
    0x63, 0x4a, 0x05, 0xc1, 0xfa, 0xce, 0x10, 0x9c, 0x1f, 0x18, 0x1a, 0x46, 0xb9, 0xb5, 0x66, 0xef,
    0xfc, 0x04, 0x29, 0x27, 0xb9, 0x3d, 0xa4, 0x85, 0x78, 0x99, 0xe4, 0x6e, 0x2e, 0xb0, 0x42, 0xbb,
    0x95, 0x93, 0x46, 0xf9, 0x70, 0x91, 0x1b, 0xf3, 0x9a, 0xfb, 0xaa, 0x96, 0x7c, 0x82, 0x77, 0x33,
    0xb9, 0x98, 0x2f, 0xa3, 0xd4, 0x24, 0x82, 0xca, 0x57, 0x74, 0xde, 0x19, 0x38, 0x3e, 0xc2, 0xda,
    0x31, 0x03, 0xf9, 0x6d, 0xcb, 0x7f, 0x5c, 0x90, 0xc8, 0x0d, 0x62, 0x31, 0xab, 0xb3, 0xde, 0x84,
    0x9b, 0x02, 0x81, 0x81, 0x00, 0xe5, 0x4f, 0x1f, 0xff, 0x19, 0x17, 0xc2, 0x40, 0xf5, 0xe4, 0x3a,
    0x88, 0xaa, 0xa5, 0x45, 0x11, 0x13, 0xe7, 0x2b, 0x14, 0x96, 0x83, 0xbb, 0x83, 0x3f, 0x75, 0x07,
    0xaa, 0x94, 0x1d, 0x82, 0xd6, 0x8a, 0x63, 0xad, 0xf1, 0x3a, 0xb4, 0x4c, 0xcd, 0x34, 0x09, 0x65,
    0xc6, 0xe2, 0x0b, 0xfd, 0xc3, 0x4d, 0x95, 0x7c, 0xf2, 0x9d, 0x5e, 0x97, 0xe1, 0x4a, 0x07, 0x5f,
    0xb2, 0x7b, 0x0a, 0x4e, 0x00, 0x40, 0xb1, 0xa5, 0x3b, 0xf6, 0x99, 0x21, 0xb5, 0x8b, 0x97, 0xc1,
    0xf1, 0x1e, 0x86, 0xfa, 0xaa, 0x03, 0x7f, 0xa8, 0x9a, 0xb1, 0x01, 0x98, 0x89, 0xf1, 0x01, 0x63,
    0x89, 0x64, 0xd4, 0x0b, 0x6e, 0x89, 0x72, 0xc9, 0x85, 0xcf, 0x55, 0x9c, 0xe8, 0x2e, 0x34, 0xbd,
    0xf3, 0x7c, 0x32, 0xc2, 0xfc, 0xf8, 0xc5, 0xf1, 0xf5, 0xa9, 0x12, 0xc0, 0xf2, 0xee, 0xb4, 0xb1,
    0x57, 0x5b, 0x10, 0xb0, 0x6b, 0x02, 0x81, 0x80, 0x74, 0xd2, 0xbd, 0x37, 0xc8, 0x79, 0x20, 0x1e,
    0x89, 0x46, 0x14, 0xd3, 0xe6, 0x43, 0xbf, 0x8a, 0x8f, 0x51, 0xe5, 0xe2, 0xc1, 0xf8, 0xe3, 0x39,
    0xb1, 0xc4, 0x0c, 0x58, 0xee, 0xc5, 0xe2, 0xde, 0xa4, 0xa5, 0xab, 0x48, 0x56, 0xa4, 0xcd, 0xd7,
    0x71, 0x90, 0x9f, 0xa3, 0x48, 0x4e, 0xbe, 0x6d, 0x8a, 0x68, 0x03, 0xfa, 0x0c, 0x85, 0x7f, 0xc7,
    0x9c, 0x2c, 0x4f, 0x1c, 0x58, 0xd2, 0xb3, 0xa8, 0xa2, 0xd1, 0xed, 0x04, 0xc0, 0x4f, 0x4c, 0x3d,
    0x83, 0xce, 0xa1, 0x2e, 0x02, 0x5e, 0xe9, 0xb3, 0xf8, 0x4e, 0xe2, 0xf0, 0x56, 0x1f, 0xd1, 0x4a,
    0xeb, 0x80, 0xf8, 0x20, 0x55, 0x7f, 0x3d, 0x3f, 0xf6, 0x1e, 0x60, 0x85, 0xd6, 0x71, 0xf7, 0xbb,
    0x05, 0xa3, 0x3d, 0xb8, 0x74, 0xc3, 0x8a, 0x05, 0x6a, 0x1f, 0xfc, 0xcf, 0x98, 0x92, 0x05, 0x13,
    0x2d, 0xcb, 0xa2, 0xde, 0x63, 0x44, 0x74, 0xf3, 0x02, 0x81, 0x80, 0x6c, 0x0b, 0xfc, 0x67, 0x96,
    0xcb, 0x3b, 0x1c, 0xa0, 0xc0, 0x09, 0x54, 0x9c, 0x13, 0x83, 0x97, 0xa8, 0x69, 0x24, 0x43, 0x6f,
    0x28, 0x63, 0x12, 0x54, 0xb4, 0x30, 0x08, 0x90, 0x01, 0xd7, 0xc4, 0x7f, 0x30, 0xb8, 0xa5, 0x11,
    0xa4, 0x23, 0x0c, 0x0d, 0x98, 0xdf, 0xfb, 0xf6, 0x46, 0xf0, 0x2b, 0x36, 0x43, 0x59, 0xbc, 0x77,
    0xaa, 0x3a, 0xa6, 0x4c, 0xdb, 0x6c, 0x9c, 0x0c, 0x9d, 0xae, 0x63, 0x30, 0x18, 0x84, 0x62, 0xdc,
    0xaf, 0x0a, 0xd3, 0x20, 0x13, 0x41, 0xae, 0xfb, 0x53, 0x5e, 0x88, 0xfd, 0x5d, 0x09, 0x74, 0xda,
    0x32, 0x86, 0x4d, 0x78, 0xe1, 0xce, 0xa4, 0xce, 0x7d, 0x9b, 0x65, 0x5a, 0x1e, 0x5c, 0x16, 0x50,
    0xbb, 0x66, 0x53, 0x80, 0x72, 0x19, 0x8e, 0xc0, 0xd6, 0xaa, 0x49, 0xc8, 0x6e, 0x7c, 0xb3, 0xe4,
    0x16, 0x92, 0x13, 0xe5, 0xa5, 0xfe, 0x69, 0xca, 0xde, 0xf2, 0x41, 0x02, 0x81, 0x80, 0x24, 0xf0,
    0x01, 0x0f, 0x34, 0xc7, 0x27, 0x2b, 0x7a, 0xf1, 0x4e, 0x04, 0x50, 0xd3, 0x18, 0x2b, 0x9c, 0x75,
    0x10, 0x22, 0x1c, 0xaa, 0x63, 0xb9, 0x7a, 0x52, 0xd3, 0x15, 0x91, 0xa6, 0xf4, 0xd4, 0xa4, 0x27,
    0x51, 0x17, 0x10, 0x01, 0xac, 0x83, 0xf7, 0x95, 0x58, 0xf4, 0x70, 0x29, 0x37, 0x65, 0x63, 0x0f,
    0x5e, 0x77, 0x75, 0xd3, 0x44, 0x83, 0xa1, 0xf0, 0x4e, 0x9b, 0x66, 0xfd, 0x4b, 0x38, 0x65, 0x2b,
    0x5d, 0x9f, 0x4d, 0x3c, 0x2e, 0xb6, 0xc9, 0xe3, 0x10, 0x3f, 0xd4, 0x14, 0x2e, 0x6f, 0x20, 0xe5,
    0x77, 0x1f, 0x92, 0x41, 0xc2, 0x60, 0x23, 0x4a, 0x98, 0xbd, 0x2b, 0x24, 0x3c, 0x23, 0x02, 0xa9,
    0x32, 0x5e, 0x21, 0xe7, 0xbe, 0x2e, 0x56, 0x90, 0xab, 0x49, 0x73, 0x49, 0x7c, 0xf9, 0xd9, 0x8c,
    0x6f, 0x46, 0xb1, 0x13, 0x32, 0x5c, 0x5e, 0x07, 0xea, 0x74, 0x02, 0x45, 0xce, 0x87,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_2K_PUBLIC_KEY: [u8; 294] = [
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xe1, 0x60, 0x77, 0xe2, 0x62, 0x3f, 0x84, 0x56, 0xc9, 0x2a, 0xc1, 0xf2, 0x09, 0x9e, 0x97,
    0x22, 0x88, 0x68, 0x47, 0xa4, 0x94, 0x35, 0x6e, 0x81, 0x85, 0xc6, 0xe6, 0x1e, 0xa8, 0x59, 0xb8,
    0x69, 0x6f, 0xfe, 0x29, 0x31, 0x96, 0xac, 0x68, 0x8a, 0x09, 0x39, 0x3b, 0x89, 0x9b, 0x96, 0xbf,
    0x8f, 0x23, 0x12, 0x61, 0xbf, 0x46, 0x69, 0x6d, 0x67, 0x28, 0x56, 0xab, 0xdf, 0x41, 0xc9, 0x5e,
    0x80, 0x0b, 0x73, 0xac, 0xbe, 0x50, 0x08, 0xe0, 0x29, 0x12, 0x71, 0xce, 0xd0, 0x8e, 0xff, 0x3e,
    0x90, 0x3d, 0x5a, 0xcc, 0x14, 0x7f, 0xa9, 0xf0, 0x68, 0xdc, 0x1c, 0xd8, 0xaf, 0x64, 0xcc, 0x0b,
    0x43, 0xb1, 0xa9, 0x3d, 0xfb, 0xe8, 0xbc, 0x90, 0x1a, 0x45, 0xd2, 0xdb, 0x17, 0xf5, 0x7a, 0xb5,
    0xb3, 0x9e, 0x64, 0x31, 0xa5, 0x43, 0xb7, 0x94, 0xa7, 0x31, 0x29, 0x79, 0x41, 0x69, 0x14, 0xdd,
    0x6d, 0x67, 0x68, 0x0a, 0x36, 0x38, 0x0e, 0x35, 0xc6, 0x62, 0xcf, 0x38, 0xcc, 0x52, 0x64, 0x8d,
    0xa6, 0x7e, 0x7e, 0x70, 0x60, 0x46, 0x29, 0x68, 0x3c, 0x42, 0x2e, 0xe2, 0xd8, 0x21, 0x6d, 0x01,
    0x65, 0xc5, 0x86, 0x36, 0xeb, 0x0f, 0x1e, 0x6d, 0xf1, 0xd8, 0x7b, 0xe0, 0x4d, 0xce, 0x71, 0xc8,
    0x35, 0x5c, 0x6f, 0x0c, 0x4a, 0x8b, 0xf8, 0x07, 0x23, 0x6b, 0xfe, 0x47, 0xdc, 0xbd, 0x02, 0xf2,
    0xff, 0xb0, 0xdf, 0xcf, 0x02, 0xf6, 0xa1, 0x4b, 0x6b, 0x99, 0xcc, 0xc6, 0x76, 0x30, 0xc5, 0xe4,
    0x02, 0xf4, 0xa2, 0x02, 0xbf, 0x71, 0x31, 0x3d, 0x80, 0x70, 0x60, 0x23, 0x12, 0xad, 0x2f, 0x02,
    0x20, 0x42, 0x67, 0x15, 0x7a, 0x6d, 0xf4, 0x58, 0x2a, 0x8a, 0x1d, 0x25, 0x1d, 0xfd, 0x01, 0x3f,
    0x83, 0x5f, 0x5a, 0xfb, 0x11, 0x98, 0xda, 0x55, 0x96, 0x8f, 0x26, 0x61, 0x25, 0x8b, 0xdb, 0xfc,
    0xc9, 0x02, 0x03, 0x01, 0x00, 0x01,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_3K_PRIVATE_KEY: [u8; 1793] = [
    0x30, 0x82, 0x06, 0xfd, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x06, 0xe7, 0x30, 0x82, 0x06, 0xe3, 0x02, 0x01,
    0x00, 0x02, 0x82, 0x01, 0x81, 0x00, 0xcf, 0xa2, 0xe7, 0x8f, 0x36, 0x38, 0xc8, 0xf4, 0xf9, 0xa5,
    0x03, 0xfa, 0x64, 0x75, 0x1d, 0xe7, 0x46, 0xc4, 0x36, 0x6e, 0x59, 0x55, 0x6c, 0xb5, 0xa7, 0x3f,
    0x91, 0x65, 0x0d, 0x7a, 0xb7, 0x94, 0x18, 0x6e, 0x81, 0xf8, 0xc7, 0x80, 0x27, 0x3c, 0xd2, 0x99,
    0x5c, 0x48, 0xdb, 0x19, 0x17, 0xb9, 0xaa, 0xf4, 0x21, 0x2c, 0xcf, 0x2f, 0xda, 0x1d, 0xe0, 0xda,
    0x6d, 0xf8, 0xae, 0xbe, 0x7a, 0x85, 0x8b, 0x3d, 0x8e, 0x59, 0xa0, 0xd8, 0xf0, 0xbd, 0xb1, 0xf9,
    0x91, 0x81, 0x04, 0x38, 0xd7, 0x70, 0x64, 0xb7, 0x5c, 0x96, 0x25, 0x15, 0xf5, 0xf6, 0xab, 0xf0,
    0xea, 0xbe, 0x62, 0x90, 0x25, 0x86, 0xfc, 0x60, 0xae, 0x1d, 0xc4, 0x3e, 0xdd, 0xda, 0xe3, 0xc5,
    0x8d, 0xe5, 0xd9, 0x7c, 0xd2, 0x49, 0x11, 0xea, 0xda, 0xee, 0xbd, 0x8c, 0x1d, 0xde, 0x4d, 0xbb,
    0x84, 0x3c, 0x95, 0x28, 0xe8, 0x7d, 0xdd, 0xac, 0xc2, 0xaa, 0xfd, 0xfc, 0xc3, 0x5f, 0xa9, 0xfa,
    0x59, 0x41, 0x28, 0xea, 0xfe, 0xee, 0xfe, 0x30, 0x7b, 0xd6, 0x9b, 0x7c, 0x94, 0x93, 0x88, 0xac,
    0x0d, 0xe8, 0x11, 0x2d, 0x58, 0x88, 0x60, 0x11, 0xdf, 0x55, 0xed, 0xb6, 0xbf, 0x0e, 0x13, 0x25,
    0x19, 0x3b, 0x0c, 0xa4, 0x42, 0xef, 0xf1, 0xac, 0x2a, 0xb9, 0xf8, 0x18, 0x83, 0xcb, 0xdd, 0xde,
    0xeb, 0xb7, 0x11, 0xab, 0xa4, 0xbc, 0xb6, 0x28, 0x97, 0x47, 0x38, 0x97, 0x7d, 0x82, 0x44, 0xe8,
    0xf9, 0xae, 0xaf, 0xfd, 0xaa, 0x52, 0x8a, 0x0d, 0xeb, 0x2f, 0x58, 0x34, 0xc8, 0x1c, 0x5d, 0x37,
    0x2c, 0xe9, 0x68, 0x52, 0x7b, 0x7a, 0x5a, 0x3f, 0x94, 0x90, 0x67, 0x05, 0x52, 0x6b, 0xda, 0xa1,
    0x93, 0xea, 0x41, 0xd0, 0x3f, 0x72, 0x98, 0x23, 0x06, 0x23, 0xb7, 0xe4, 0xc4, 0x67, 0xfe, 0xa0,
    0xd1, 0x97, 0xfb, 0x92, 0x8b, 0x94, 0x08, 0xf9, 0x56, 0x9b, 0x66, 0xc1, 0x03, 0x23, 0xdb, 0xe5,
    0xb2, 0x1f, 0x73, 0x11, 0x7a, 0xfc, 0x9b, 0x10, 0x1d, 0xe8, 0xf3, 0x22, 0xff, 0x13, 0x11, 0x0f,
    0x81, 0x33, 0xf9, 0x04, 0xd1, 0xaa, 0x34, 0xfc, 0xbf, 0xb0, 0xa7, 0x8f, 0xcf, 0xc1, 0x96, 0x7c,
    0xf5, 0x8e, 0xa3, 0xaa, 0xd4, 0x39, 0x4c, 0xd4, 0xf8, 0x23, 0x4e, 0xe0, 0x7e, 0x68, 0x9f, 0xfd,
    0xaa, 0x26, 0x47, 0x4f, 0x93, 0x02, 0x1a, 0xc1, 0x2d, 0x2f, 0x8f, 0xf3, 0xf7, 0x4b, 0x2f, 0xde,
    0xb2, 0x84, 0x5a, 0x1f, 0x46, 0xf5, 0x34, 0x39, 0x64, 0xba, 0x50, 0x48, 0xaa, 0x45, 0x72, 0xb8,
    0x08, 0xc2, 0x97, 0x25, 0x1d, 0xe1, 0xe6, 0xb7, 0x66, 0x47, 0xf9, 0xc3, 0xcf, 0x04, 0x3d, 0x0f,
    0x4c, 0x7e, 0x3e, 0x2c, 0xfd, 0x17, 0xae, 0xfb, 0x4d, 0xd5, 0xcb, 0x61, 0x9c, 0x22, 0x1e, 0xe3,
    0xc5, 0x19, 0x01, 0x94, 0x17, 0x3d, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01, 0x80, 0x2b,
    0xa1, 0x34, 0x7d, 0x10, 0x4c, 0xb0, 0x55, 0x61, 0x9b, 0xbe, 0x11, 0x40, 0x48, 0xa7, 0xc6, 0xf0,
    0x44, 0xcc, 0x97, 0x35, 0x68, 0x50, 0xd6, 0x7e, 0xd5, 0x49, 0xac, 0xed, 0x3f, 0x2b, 0x12, 0x10,
    0x6c, 0x30, 0x1d, 0x61, 0x76, 0x59, 0x48, 0x5b, 0x8c, 0x64, 0x2a, 0xde, 0xf7, 0x0f, 0xd8, 0x30,
    0xc6, 0xe9, 0xad, 0xab, 0xbf, 0x87, 0x5a, 0x9d, 0xe3, 0xe8, 0x15, 0xc8, 0x4a, 0x38, 0x1e, 0x95,
    0x9a, 0x92, 0xad, 0xdc, 0xb1, 0x99, 0x2c, 0x93, 0x18, 0x38, 0xed, 0xde, 0x40, 0x3f, 0x6c, 0xdb,
    0x8c, 0xf8, 0x04, 0x88, 0xb8, 0x6b, 0x9d, 0xb0, 0x95, 0x88, 0x0e, 0x07, 0x51, 0xf8, 0xc0, 0xbb,
    0x89, 0x69, 0x2c, 0xd2, 0x0e, 0xcf, 0xb9, 0x6e, 0x01, 0x16, 0x07, 0x05, 0x43, 0x48, 0x40, 0x98,
    0x66, 0x3c, 0x28, 0xcc, 0x65, 0x83, 0xe5, 0x31, 0x7a, 0x44, 0x98, 0x22, 0x53, 0x9d, 0x3e, 0xcd,
    0x74, 0xbe, 0xd7, 0x05, 0x55, 0xb6, 0x8c, 0x04, 0x80, 0x99, 0x7e, 0xaa, 0xa5, 0x6e, 0x7a, 0x33,
    0xa9, 0x66, 0x6c, 0x3a, 0xf1, 0xdb, 0x9a, 0x80, 0xae, 0x7e, 0xa1, 0x93, 0xf2, 0x6e, 0x57, 0x01,
    0xb0, 0xdf, 0xb8, 0x03, 0xa2, 0x51, 0xd5, 0x18, 0x4a, 0xc4, 0x59, 0x77, 0x17, 0x91, 0x05, 0x30,
    0x48, 0x18, 0x16, 0x49, 0xbe, 0x84, 0xfb, 0x32, 0x9c, 0xe3, 0xf4, 0xec, 0xde, 0x9f, 0x57, 0xb3,
    0x07, 0x1c, 0xd7, 0xd4, 0xbd, 0x68, 0x1f, 0x30, 0x0c, 0xc6, 0xeb, 0xaf, 0xaa, 0x67, 0x7b, 0x47,
    0x23, 0x65, 0x5e, 0x54, 0x3e, 0x13, 0x9d, 0xf5, 0x38, 0x1f, 0x9b, 0xf5, 0x66, 0x34, 0xa3, 0x57,
    0xd3, 0x95, 0xbc, 0xd1, 0x53, 0x99, 0x06, 0x2e, 0xe4, 0x0e, 0x91, 0x3f, 0x32, 0x22, 0x1e, 0x91,
    0x19, 0x4a, 0x1e, 0x60, 0x97, 0xbb, 0xd6, 0x06, 0x8c, 0xb9, 0x92, 0xca, 0x0b, 0x4f, 0xa6, 0xda,
    0x51, 0x1e, 0x26, 0xb7, 0x59, 0x24, 0x92, 0xf1, 0xb5, 0xce, 0x0c, 0x43, 0x49, 0xf0, 0xe7, 0x82,
    0xdc, 0x92, 0x33, 0x10, 0x7b, 0x86, 0x9f, 0xa4, 0xe9, 0xfa, 0x49, 0x1f, 0x66, 0xe5, 0x45, 0x27,
    0xa2, 0xe2, 0xea, 0x86, 0xcf, 0xa0, 0x17, 0x80, 0x7a, 0xeb, 0x78, 0x64, 0x6b, 0x0a, 0xcd, 0x62,
    0xc1, 0xd5, 0x20, 0x3f, 0xc7, 0x39, 0xdc, 0x9a, 0xbe, 0x9a, 0x76, 0xed, 0x05, 0x4d, 0x1f, 0x1f,
    0x07, 0x6a, 0xcf, 0x0e, 0x5f, 0xd6, 0x06, 0x22, 0x9c, 0xc6, 0x49, 0x06, 0x30, 0xff, 0x6d, 0x77,
    0xac, 0x01, 0x73, 0xe2, 0x5c, 0x99, 0x17, 0xcb, 0xc1, 0xf0, 0x4a, 0xad, 0x27, 0xad, 0x48, 0xcd,
    0x7a, 0xa0, 0x38, 0xb8, 0x5c, 0xf6, 0x2d, 0x9a, 0x6d, 0xa2, 0x5b, 0x1f, 0xfd, 0xac, 0x31, 0x8b,
    0xe5, 0x95, 0xe9, 0x97, 0x12, 0x4e, 0xc4, 0xe1, 0xf4, 0xc3, 0x67, 0x50, 0x06, 0x23, 0x81, 0x02,
    0x81, 0xc1, 0x00, 0xf0, 0xdc, 0x47, 0x73, 0xf7, 0xe2, 0xf6, 0x65, 0xcb, 0xa3, 0x07, 0x3f, 0x7d,
    0x23, 0x53, 0xfe, 0x6f, 0x6d, 0x6f, 0xdf, 0xbd, 0x8c, 0x93, 0xe1, 0xef, 0xe8, 0x35, 0x56, 0x6e,
    0x77, 0x83, 0x7b, 0xd7, 0x13, 0xbe, 0x09, 0xff, 0x0e, 0x98, 0x65, 0x48, 0xc6, 0x33, 0x49, 0x45,
    0x00, 0xdf, 0xd1, 0x3e, 0xa9, 0x6c, 0x34, 0xc6, 0x2d, 0x1c, 0x7a, 0xb2, 0xcf, 0x57, 0xb2, 0x00,
    0x2c, 0x61, 0x38, 0x71, 0x6c, 0x4a, 0xc5, 0x87, 0x85, 0x06, 0xe7, 0xe0, 0x39, 0x73, 0x15, 0xd0,
    0xb7, 0xf2, 0xf7, 0xc9, 0x10, 0x69, 0x6c, 0x90, 0x4f, 0x61, 0x3c, 0xf8, 0x28, 0x3b, 0x5b, 0xe1,
    0x57, 0x7c, 0x32, 0x25, 0xca, 0x7c, 0x2c, 0x9d, 0x6c, 0x30, 0x82, 0x5b, 0x17, 0xb3, 0xc4, 0x66,
    0x83, 0xc5, 0xc5, 0x14, 0x78, 0xd1, 0xe6, 0xb4, 0x9a, 0x95, 0xaf, 0x27, 0xe4, 0x1f, 0xb4, 0xf8,
    0x06, 0xfb, 0x38, 0x2d, 0x82, 0xa8, 0x39, 0xab, 0x7c, 0x2a, 0x6a, 0xf3, 0xd2, 0xa8, 0x09, 0x89,
    0x5f, 0xfc, 0xfa, 0xe6, 0x9a, 0x51, 0x82, 0x27, 0xb2, 0x04, 0x49, 0x72, 0x2c, 0xbe, 0x4b, 0xf6,
    0x72, 0x98, 0x74, 0xca, 0xf7, 0x49, 0xc8, 0xf1, 0xee, 0x93, 0x8d, 0x38, 0x65, 0xd2, 0x4c, 0xb9,
    0xe4, 0x18, 0x17, 0x59, 0xf0, 0xa6, 0xdc, 0x22, 0xf7, 0x6b, 0x29, 0x15, 0xcd, 0x05, 0x85, 0xe6,
    0x5a, 0xb2, 0x5d, 0x02, 0x81, 0xc1, 0x00, 0xdc, 0xb0, 0x02, 0xe2, 0x13, 0x9a, 0x18, 0x7d, 0xad,
    0x31, 0xf6, 0xaa, 0x0b, 0x03, 0x66, 0x3a, 0x8c, 0xd4, 0x7c, 0x8b, 0x01, 0x78, 0x39, 0xf4, 0x07,
    0xce, 0x83, 0xcb, 0x9e, 0x72, 0x40, 0x72, 0x6d, 0xff, 0xb2, 0x01, 0xd7, 0x53, 0xd6, 0x1e, 0x70,
    0xcc, 0xc1, 0xe2, 0x8e, 0xe1, 0xad, 0xbb, 0x47, 0x38, 0xf5, 0xe7, 0x3c, 0x1c, 0x97, 0x2e, 0x98,
    0x4d, 0x22, 0x16, 0xd7, 0xd5, 0xbf, 0x3d, 0x88, 0x6b, 0x5f, 0x15, 0x67, 0x12, 0x91, 0x95, 0x43,
    0xbb, 0x45, 0x73, 0x29, 0x83, 0x26, 0x78, 0x44, 0x6a, 0xdf, 0xc0, 0x48, 0x28, 0x6b, 0xd3, 0x9d,
    0x66, 0x5e, 0x15, 0x55, 0x43, 0xc4, 0xbf, 0x1c, 0x7c, 0xbe, 0x25, 0x1b, 0x4b, 0x71, 0x75, 0x3e,
    0x49, 0xa6, 0xee, 0x65, 0xe9, 0x72, 0x1f, 0xde, 0x2d, 0x44, 0xa1, 0x28, 0x15, 0xf4, 0x40, 0xd8,
    0xe9, 0x5a, 0x27, 0xb4, 0x25, 0xc5, 0x87, 0xc8, 0x0d, 0xfc, 0x04, 0xf2, 0x60, 0x08, 0xfe, 0xee,
    0xdd, 0x28, 0xcd, 0xae, 0x0a, 0x28, 0x3a, 0x87, 0x72, 0x07, 0x9a, 0x50, 0xeb, 0x5a, 0x85, 0x66,
    0xec, 0x4a, 0x9e, 0x88, 0x1d, 0x75, 0xc8, 0x84, 0xcf, 0xdc, 0xc8, 0x56, 0x7e, 0x04, 0x7c, 0x01,
    0xf1, 0x89, 0x0d, 0x17, 0xc7, 0xa7, 0xa6, 0xa2, 0x80, 0xb8, 0x34, 0x66, 0xe3, 0x40, 0x40, 0x04,
    0x34, 0xd1, 0xe7, 0x1b, 0x0c, 0x6a, 0x61, 0x02, 0x81, 0xc0, 0x24, 0x47, 0x19, 0x60, 0x07, 0x33,
    0x21, 0x27, 0x9d, 0xef, 0x55, 0x35, 0x23, 0xd5, 0x01, 0x5e, 0xae, 0x4b, 0xce, 0x70, 0xe5, 0xac,
    0xd9, 0xcd, 0x4b, 0x04, 0x2f, 0x9c, 0x70, 0x11, 0x02, 0x35, 0xd1, 0xe4, 0x40, 0x58, 0x63, 0x19,
    0x40, 0xac, 0xe8, 0xb4, 0x29, 0x9f, 0x5c, 0x8c, 0x50, 0x29, 0xc5, 0x05, 0x61, 0xad, 0xe5, 0x37,
    0x80, 0x35, 0x9e, 0xdf, 0x09, 0xf7, 0x5e, 0x7d, 0x50, 0xbb, 0x5e, 0xa2, 0x0f, 0xf5, 0x06, 0x7f,
    0x6b, 0xd5, 0xda, 0xf8, 0xec, 0x33, 0x99, 0xf7, 0x4a, 0xda, 0x35, 0x67, 0x8a, 0x69, 0x76, 0xa6,
    0xee, 0x1f, 0x6f, 0xc5, 0x27, 0x83, 0xa4, 0x42, 0x38, 0x0b, 0x99, 0x93, 0x90, 0xf6, 0x6b, 0x53,
    0x93, 0x4e, 0xdf, 0x07, 0x87, 0xe5, 0x0a, 0x07, 0xc8, 0xee, 0xf1, 0x31, 0x6d, 0x74, 0x11, 0x39,
    0xc3, 0x57, 0xd9, 0x6b, 0x4b, 0xb7, 0x47, 0x30, 0x4e, 0x00, 0x5d, 0x22, 0x73, 0xd2, 0x13, 0xd9,
    0x24, 0xce, 0x6d, 0x21, 0x0a, 0x7c, 0x3d, 0x3b, 0xbe, 0xef, 0xcf, 0x71, 0xe8, 0xda, 0xf0, 0xbd,
    0xa8, 0x55, 0xa3, 0xa3, 0xc7, 0x99, 0xcb, 0x69, 0xe1, 0x3a, 0x9e, 0x23, 0x76, 0xf2, 0x94, 0x35,
    0xf9, 0xf5, 0x68, 0x4c, 0x35, 0xcb, 0xa6, 0xa8, 0x0b, 0x54, 0xe1, 0x10, 0x15, 0x21, 0xcd, 0x06,
    0x75, 0x16, 0x80, 0x19, 0x1c, 0x3e, 0xd9, 0xbe, 0x49, 0x65, 0x02, 0x81, 0xc0, 0x0b, 0x21, 0x11,
    0x34, 0x27, 0x7a, 0xe8, 0xeb, 0x45, 0x95, 0xb4, 0x73, 0xc4, 0xd4, 0x6a, 0x0e, 0x5f, 0xd5, 0xc3,
    0x66, 0x1b, 0x2f, 0xdd, 0xf4, 0x51, 0x84, 0x77, 0x9f, 0x08, 0x21, 0x88, 0xe0, 0x7c, 0x6d, 0x9d,
    0xa3, 0x7c, 0x21, 0x6d, 0x35, 0xe1, 0xc8, 0x61, 0xaa, 0xb4, 0x3b, 0xeb, 0x4f, 0xfb, 0x7a, 0x82,
    0xe4, 0x23, 0x62, 0xe9, 0xb8, 0xde, 0xd3, 0x5c, 0xf9, 0xbb, 0xee, 0xba, 0x93, 0x36, 0xd2, 0xfb,
    0x5b, 0x8f, 0xf4, 0x1e, 0xc5, 0x61, 0x42, 0x0b, 0x71, 0x90, 0x51, 0x5d, 0xda, 0x48, 0xd0, 0xfe,
    0xf1, 0xaa, 0x71, 0xe7, 0x66, 0x27, 0x94, 0xe6, 0xff, 0xba, 0x6a, 0x0d, 0x7c, 0xf9, 0xc9, 0xcc,
    0xa9, 0x00, 0x64, 0x60, 0x97, 0x62, 0x09, 0xc2, 0xd2, 0x58, 0xef, 0x59, 0xe3, 0x03, 0x88, 0x52,
    0xe2, 0xb1, 0xab, 0xd1, 0xc2, 0x87, 0x6d, 0xd5, 0x2f, 0x15, 0x65, 0xa6, 0x3d, 0x7f, 0xb8, 0x3c,
    0xd2, 0x5f, 0x0a, 0xba, 0xc9, 0x68, 0x70, 0x5c, 0xc3, 0x6a, 0x98, 0x76, 0x88, 0xe5, 0x15, 0xba,
    0x0e, 0x6d, 0x30, 0x41, 0x43, 0x62, 0xfa, 0x5d, 0x94, 0xfb, 0x16, 0x49, 0x3f, 0x50, 0x7b, 0x4f,
    0x0e, 0x07, 0x56, 0x99, 0x91, 0x4b, 0x63, 0xcb, 0xde, 0x8e, 0x29, 0x72, 0x69, 0xf3, 0xdd, 0xfb,
    0xec, 0x20, 0x98, 0x2b, 0x40, 0x4f, 0x35, 0xfe, 0xb3, 0xe1, 0xe8, 0x51, 0x61, 0x02, 0x81, 0xc1,
    0x00, 0xca, 0xb5, 0x67, 0xa0, 0x44, 0x81, 0x55, 0x21, 0x81, 0x69, 0x86, 0x69, 0x96, 0xa9, 0x53,
    0x49, 0x15, 0x10, 0x38, 0x97, 0xa6, 0x26, 0x87, 0x53, 0x70, 0x4e, 0xfe, 0x2e, 0x1f, 0xdf, 0x38,
    0x6f, 0x5b, 0x61, 0xa2, 0x3a, 0x50, 0xa5, 0x1c, 0x05, 0x62, 0xd5, 0xc3, 0x8f, 0x09, 0x6c, 0x1e,
    0x82, 0xdf, 0x77, 0x06, 0x0e, 0xc0, 0x91, 0x47, 0xb7, 0xd9, 0x51, 0x7f, 0x68, 0x02, 0x51, 0xe6,
    0x3a, 0x86, 0x44, 0x05, 0x84, 0xf4, 0x8d, 0x29, 0x10, 0x00, 0x9b, 0x86, 0x4e, 0xc2, 0x81, 0x03,
    0x52, 0xaf, 0x43, 0x4c, 0x8f, 0x24, 0x5f, 0x79, 0x30, 0x76, 0xd0, 0xdd, 0x6e, 0x2b, 0x1c, 0x3e,
    0xf8, 0x3c, 0xdc, 0x4c, 0x99, 0x78, 0x6e, 0xaa, 0x16, 0xff, 0xac, 0x36, 0x2d, 0x15, 0xa7, 0x65,
    0xf0, 0x2c, 0x0a, 0xf8, 0x03, 0x07, 0x47, 0xc4, 0x85, 0xcc, 0x28, 0x71, 0x31, 0xf6, 0x1b, 0xa7,
    0x13, 0x39, 0xbb, 0xe4, 0x4b, 0xe9, 0x79, 0xa5, 0x27, 0x9a, 0xe9, 0x13, 0xca, 0xdb, 0x6b, 0x77,
    0xed, 0xb2, 0xda, 0xf4, 0x7b, 0x4a, 0x39, 0x79, 0x99, 0x77, 0x6f, 0x8a, 0xe3, 0xbe, 0x91, 0xe0,
    0xa2, 0xc5, 0x92, 0x68, 0x4c, 0x83, 0xf0, 0x27, 0x32, 0x3e, 0x3f, 0x14, 0x16, 0xe4, 0x2b, 0x1c,
    0xbf, 0x61, 0x7d, 0x7a, 0xd9, 0x01, 0x78, 0xfa, 0xe1, 0x0f, 0x48, 0x52, 0x49, 0x12, 0xe2, 0x10,
    0x38,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_3K_PUBLIC_KEY: [u8; 422] = [
    0x30, 0x82, 0x01, 0xa2, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x8f, 0x00, 0x30, 0x82, 0x01, 0x8a, 0x02, 0x82, 0x01, 0x81,
    0x00, 0xcf, 0xa2, 0xe7, 0x8f, 0x36, 0x38, 0xc8, 0xf4, 0xf9, 0xa5, 0x03, 0xfa, 0x64, 0x75, 0x1d,
    0xe7, 0x46, 0xc4, 0x36, 0x6e, 0x59, 0x55, 0x6c, 0xb5, 0xa7, 0x3f, 0x91, 0x65, 0x0d, 0x7a, 0xb7,
    0x94, 0x18, 0x6e, 0x81, 0xf8, 0xc7, 0x80, 0x27, 0x3c, 0xd2, 0x99, 0x5c, 0x48, 0xdb, 0x19, 0x17,
    0xb9, 0xaa, 0xf4, 0x21, 0x2c, 0xcf, 0x2f, 0xda, 0x1d, 0xe0, 0xda, 0x6d, 0xf8, 0xae, 0xbe, 0x7a,
    0x85, 0x8b, 0x3d, 0x8e, 0x59, 0xa0, 0xd8, 0xf0, 0xbd, 0xb1, 0xf9, 0x91, 0x81, 0x04, 0x38, 0xd7,
    0x70, 0x64, 0xb7, 0x5c, 0x96, 0x25, 0x15, 0xf5, 0xf6, 0xab, 0xf0, 0xea, 0xbe, 0x62, 0x90, 0x25,
    0x86, 0xfc, 0x60, 0xae, 0x1d, 0xc4, 0x3e, 0xdd, 0xda, 0xe3, 0xc5, 0x8d, 0xe5, 0xd9, 0x7c, 0xd2,
    0x49, 0x11, 0xea, 0xda, 0xee, 0xbd, 0x8c, 0x1d, 0xde, 0x4d, 0xbb, 0x84, 0x3c, 0x95, 0x28, 0xe8,
    0x7d, 0xdd, 0xac, 0xc2, 0xaa, 0xfd, 0xfc, 0xc3, 0x5f, 0xa9, 0xfa, 0x59, 0x41, 0x28, 0xea, 0xfe,
    0xee, 0xfe, 0x30, 0x7b, 0xd6, 0x9b, 0x7c, 0x94, 0x93, 0x88, 0xac, 0x0d, 0xe8, 0x11, 0x2d, 0x58,
    0x88, 0x60, 0x11, 0xdf, 0x55, 0xed, 0xb6, 0xbf, 0x0e, 0x13, 0x25, 0x19, 0x3b, 0x0c, 0xa4, 0x42,
    0xef, 0xf1, 0xac, 0x2a, 0xb9, 0xf8, 0x18, 0x83, 0xcb, 0xdd, 0xde, 0xeb, 0xb7, 0x11, 0xab, 0xa4,
    0xbc, 0xb6, 0x28, 0x97, 0x47, 0x38, 0x97, 0x7d, 0x82, 0x44, 0xe8, 0xf9, 0xae, 0xaf, 0xfd, 0xaa,
    0x52, 0x8a, 0x0d, 0xeb, 0x2f, 0x58, 0x34, 0xc8, 0x1c, 0x5d, 0x37, 0x2c, 0xe9, 0x68, 0x52, 0x7b,
    0x7a, 0x5a, 0x3f, 0x94, 0x90, 0x67, 0x05, 0x52, 0x6b, 0xda, 0xa1, 0x93, 0xea, 0x41, 0xd0, 0x3f,
    0x72, 0x98, 0x23, 0x06, 0x23, 0xb7, 0xe4, 0xc4, 0x67, 0xfe, 0xa0, 0xd1, 0x97, 0xfb, 0x92, 0x8b,
    0x94, 0x08, 0xf9, 0x56, 0x9b, 0x66, 0xc1, 0x03, 0x23, 0xdb, 0xe5, 0xb2, 0x1f, 0x73, 0x11, 0x7a,
    0xfc, 0x9b, 0x10, 0x1d, 0xe8, 0xf3, 0x22, 0xff, 0x13, 0x11, 0x0f, 0x81, 0x33, 0xf9, 0x04, 0xd1,
    0xaa, 0x34, 0xfc, 0xbf, 0xb0, 0xa7, 0x8f, 0xcf, 0xc1, 0x96, 0x7c, 0xf5, 0x8e, 0xa3, 0xaa, 0xd4,
    0x39, 0x4c, 0xd4, 0xf8, 0x23, 0x4e, 0xe0, 0x7e, 0x68, 0x9f, 0xfd, 0xaa, 0x26, 0x47, 0x4f, 0x93,
    0x02, 0x1a, 0xc1, 0x2d, 0x2f, 0x8f, 0xf3, 0xf7, 0x4b, 0x2f, 0xde, 0xb2, 0x84, 0x5a, 0x1f, 0x46,
    0xf5, 0x34, 0x39, 0x64, 0xba, 0x50, 0x48, 0xaa, 0x45, 0x72, 0xb8, 0x08, 0xc2, 0x97, 0x25, 0x1d,
    0xe1, 0xe6, 0xb7, 0x66, 0x47, 0xf9, 0xc3, 0xcf, 0x04, 0x3d, 0x0f, 0x4c, 0x7e, 0x3e, 0x2c, 0xfd,
    0x17, 0xae, 0xfb, 0x4d, 0xd5, 0xcb, 0x61, 0x9c, 0x22, 0x1e, 0xe3, 0xc5, 0x19, 0x01, 0x94, 0x17,
    0x3d, 0x02, 0x03, 0x01, 0x00, 0x01,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_4K_PRIVATE_KEY: [u8; 2375] = [
    0x30, 0x82, 0x09, 0x43, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x09, 0x2d, 0x30, 0x82, 0x09, 0x29, 0x02, 0x01,
    0x00, 0x02, 0x82, 0x02, 0x01, 0x00, 0xc8, 0x51, 0xcf, 0xa8, 0x62, 0x9f, 0x0a, 0x4c, 0xa3, 0x6d,
    0x30, 0x29, 0x65, 0x40, 0x00, 0x60, 0x81, 0xfd, 0xf7, 0x26, 0xcd, 0xd1, 0x8b, 0x6b, 0x01, 0x3f,
    0x9e, 0x6e, 0x2f, 0x54, 0xd2, 0xb9, 0x63, 0x4e, 0xf1, 0xca, 0xd7, 0x29, 0x27, 0xdf, 0xc0, 0x2e,
    0x27, 0x4c, 0xf5, 0xf0, 0x13, 0x4d, 0xe7, 0xca, 0xad, 0xba, 0x23, 0x11, 0xfc, 0xd3, 0xfb, 0xe2,
    0x0c, 0xea, 0xb5, 0x68, 0x55, 0xb1, 0xa7, 0x9b, 0x40, 0xb0, 0x1c, 0x82, 0x74, 0x6d, 0xd4, 0x82,
    0x81, 0x59, 0xe7, 0xed, 0x84, 0x4f, 0xe4, 0x3b, 0x3e, 0x2a, 0x55, 0xbe, 0x6e, 0x16, 0x38, 0x67,
    0x1d, 0xc2, 0xf5, 0x58, 0x3c, 0x24, 0x3a, 0xc6, 0xb9, 0xaa, 0xcd, 0x31, 0xe0, 0x35, 0xe5, 0xa6,
    0x5b, 0xbe, 0x40, 0x6a, 0x11, 0x19, 0x19, 0x5c, 0x8c, 0xf5, 0x00, 0x70, 0xb3, 0x99, 0xc1, 0x13,
    0xd9, 0x04, 0x05, 0xf6, 0x9c, 0xcc, 0x15, 0x1a, 0x24, 0x16, 0x73, 0x63, 0x95, 0x02, 0x6d, 0x59,
    0x27, 0x75, 0xed, 0xd3, 0x45, 0xff, 0x99, 0xdb, 0xfb, 0x0b, 0x7d, 0xba, 0x8d, 0x94, 0x34, 0xe1,
    0xe9, 0x00, 0x55, 0x35, 0xb9, 0x4e, 0x26, 0xaf, 0xa0, 0xeb, 0x7e, 0x4b, 0xe3, 0xaa, 0xf7, 0xca,
    0x9e, 0x21, 0xa3, 0x7b, 0x51, 0xc1, 0x74, 0xa7, 0x24, 0x92, 0xad, 0xff, 0x08, 0x1f, 0x7e, 0x8d,
    0xcd, 0x5b, 0x30, 0x13, 0xc9, 0x1a, 0xd8, 0x6a, 0x6f, 0x25, 0xdf, 0xfb, 0x21, 0xc0, 0xc9, 0x9e,
    0x54, 0x42, 0x15, 0x36, 0x0e, 0x2d, 0xca, 0xe4, 0x60, 0x9e, 0xf2, 0xd9, 0x93, 0x14, 0x29, 0x9c,
    0xed, 0x97, 0x02, 0x8c, 0xd0, 0x19, 0x55, 0xc7, 0xdb, 0x80, 0x1a, 0xa8, 0x73, 0x78, 0x0c, 0x2b,
    0x9d, 0x19, 0x37, 0xae, 0x6d, 0x6a, 0x0f, 0x20, 0xc2, 0xe6, 0x6e, 0xb2, 0x11, 0x85, 0x90, 0x40,
    0x12, 0x11, 0xc8, 0x1e, 0x63, 0x02, 0xb5, 0x44, 0xad, 0xd7, 0xd8, 0x37, 0xff, 0x7a, 0x46, 0x3f,
    0xbe, 0xce, 0x8d, 0xdf, 0x03, 0x92, 0x93, 0xb0, 0x21, 0x34, 0x9c, 0x21, 0x38, 0x21, 0x3c, 0x18,
    0x95, 0x2e, 0xcd, 0x04, 0x3c, 0xa2, 0x19, 0x1f, 0xbf, 0x99, 0x6d, 0xe4, 0x5d, 0x00, 0x03, 0xc4,
    0xf7, 0x09, 0x6e, 0x4b, 0x60, 0xb5, 0x2f, 0x29, 0xe0, 0x4f, 0x04, 0x16, 0xd0, 0x59, 0x4d, 0x54,
    0xfd, 0x44, 0x28, 0xb9, 0x73, 0x05, 0x42, 0x33, 0xe5, 0x99, 0xcf, 0x83, 0xb6, 0xa9, 0xdc, 0xb4,
    0x1a, 0x72, 0x34, 0xc2, 0xa8, 0x79, 0xd8, 0x27, 0x6f, 0x3e, 0x80, 0x98, 0x01, 0xcc, 0x33, 0xc0,
    0x6d, 0x1d, 0x95, 0x1a, 0x41, 0x80, 0x3b, 0x41, 0x4c, 0xea, 0x64, 0x92, 0x74, 0xa2, 0x65, 0xf3,
    0xc5, 0xff, 0xb7, 0xe4, 0x9e, 0x5f, 0x23, 0xd3, 0x2f, 0x1a, 0x7b, 0xc1, 0x3a, 0x17, 0x9d, 0x93,
    0xdb, 0x8d, 0x54, 0xb1, 0x75, 0x0d, 0x86, 0x4b, 0x74, 0x40, 0xb0, 0x7e, 0x7a, 0x2b, 0xc0, 0x42,
    0x09, 0x93, 0x8b, 0x34, 0x11, 0x72, 0x25, 0xdb, 0x0f, 0x2c, 0x3c, 0x39, 0x24, 0xe9, 0x9a, 0x97,
    0x7f, 0x04, 0x31, 0xe0, 0x17, 0xd2, 0x21, 0x7a, 0x69, 0x27, 0xee, 0x34, 0x89, 0xbd, 0x66, 0x47,
    0xe6, 0xa1, 0x0b, 0x20, 0x44, 0x30, 0x62, 0x58, 0x6c, 0x6c, 0xbe, 0x0f, 0xb9, 0x74, 0xac, 0x56,
    0x5f, 0x74, 0x4c, 0x9c, 0x90, 0x18, 0x91, 0xdd, 0xc1, 0xd4, 0xfb, 0x83, 0x10, 0x1a, 0x77, 0xf2,
    0x1e, 0x86, 0x8d, 0x19, 0xf0, 0x77, 0x5e, 0xe2, 0x1e, 0x09, 0xbd, 0x6a, 0x16, 0xd5, 0x4a, 0xba,
    0x94, 0xbc, 0xaa, 0x7a, 0x72, 0xe2, 0x5e, 0xc9, 0x36, 0xf6, 0x30, 0x8d, 0xbe, 0x42, 0x64, 0xa4,
    0x9b, 0x3a, 0x26, 0x89, 0x83, 0xc3, 0x6c, 0x43, 0xf1, 0x48, 0xcf, 0xaa, 0x76, 0xa1, 0x7d, 0xa7,
    0x5b, 0xd9, 0xe9, 0x2f, 0x46, 0xa3, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x02, 0x00, 0x40,
    0x01, 0x43, 0xe4, 0x7d, 0x7e, 0x6b, 0x80, 0x09, 0x47, 0xbd, 0xf7, 0xbc, 0x0e, 0x33, 0x10, 0xa2,
    0xf8, 0x4e, 0x9b, 0xeb, 0x6f, 0x64, 0xa8, 0x90, 0x01, 0x8f, 0xd1, 0x8c, 0xf6, 0x01, 0x4e, 0x92,
    0xd8, 0x8a, 0x91, 0x51, 0x26, 0x29, 0x43, 0x68, 0xd8, 0x56, 0x5e, 0x54, 0xc6, 0x9c, 0xa4, 0x6b,
    0xc7, 0x6a, 0xb2, 0xea, 0xb9, 0xb8, 0x9a, 0xd3, 0x04, 0x6b, 0x34, 0x23, 0x3a, 0x6f, 0x07, 0x10,
    0x92, 0x9e, 0x9c, 0xa6, 0xbf, 0x58, 0x0c, 0x2f, 0xb6, 0x73, 0x36, 0x12, 0xd0, 0xe5, 0x51, 0xd1,
    0x8e, 0xcc, 0x52, 0x22, 0x8b, 0x72, 0x09, 0x4f, 0x84, 0x43, 0x12, 0x23, 0xea, 0x49, 0x6d, 0x1a,
    0x0a, 0x9d, 0x10, 0x61, 0xf7, 0xe9, 0xb7, 0xce, 0xe4, 0xd4, 0xb3, 0x79, 0x49, 0x6a, 0xa5, 0x26,
    0x61, 0x57, 0xf8, 0x80, 0x67, 0x82, 0x3b, 0x42, 0x61, 0xe1, 0x19, 0x53, 0xfe, 0x74, 0x23, 0x11,
    0x2b, 0x05, 0x14, 0xd7, 0x51, 0x9e, 0x2e, 0xe4, 0x59, 0x74, 0x2e, 0x4e, 0x0b, 0x0f, 0x76, 0x97,
    0xe6, 0x9d, 0xd4, 0x12, 0x1c, 0x25, 0x58, 0x91, 0x7d, 0x0d, 0x41, 0xb9, 0xf8, 0x2c, 0x79, 0x38,
    0x0b, 0x2d, 0xd3, 0x90, 0xcb, 0x16, 0xb7, 0x6d, 0xed, 0x23, 0x91, 0x83, 0xf6, 0xc7, 0x2c, 0x94,
    0xe5, 0x42, 0xde, 0x4b, 0x12, 0x0d, 0xba, 0x62, 0x69, 0x54, 0x90, 0x2a, 0x50, 0x68, 0x15, 0x57,
    0xc8, 0xca, 0x32, 0xc3, 0xda, 0x2d, 0xf2, 0xb7, 0x79, 0x0b, 0x5b, 0x02, 0x03, 0xff, 0x8b, 0xca,
    0x24, 0x26, 0x6b, 0x23, 0x15, 0x39, 0xd5, 0x5b, 0x66, 0x74, 0xd3, 0xa7, 0x50, 0xee, 0xbc, 0xe9,
    0x97, 0xae, 0x1e, 0xc4, 0x65, 0xc6, 0x5f, 0x39, 0x24, 0x46, 0x51, 0xe4, 0x64, 0xab, 0x39, 0x14,
    0x14, 0x57, 0xb1, 0xe0, 0xf4, 0xac, 0x7c, 0x8c, 0x96, 0xac, 0x2f, 0x5a, 0x4d, 0xbb, 0x3c, 0x75,
    0x53, 0x23, 0xf6, 0x86, 0xc8, 0x3a, 0x08, 0xad, 0x07, 0x1f, 0xd1, 0x1b, 0x86, 0xa0, 0x98, 0x65,
    0x42, 0x9e, 0x2b, 0x3c, 0x6c, 0x3b, 0x60, 0x85, 0x96, 0x27, 0x25, 0x02, 0xd0, 0xb3, 0x1f, 0x1b,
    0xda, 0xe3, 0x2f, 0xb1, 0x8b, 0xdb, 0x31, 0xa4, 0x41, 0xe6, 0x4c, 0x3a, 0x05, 0xb8, 0x63, 0xd5,
    0x90, 0xec, 0xfa, 0xf9, 0x24, 0x8d, 0xe2, 0x21, 0xf4, 0x42, 0x9f, 0x8c, 0x3c, 0x31, 0x07, 0x13,
    0x17, 0x1d, 0x3c, 0xef, 0xa9, 0xe6, 0xb6, 0xe9, 0x91, 0xed, 0x1a, 0xf4, 0x42, 0xea, 0x13, 0xf4,
    0x51, 0xd2, 0xea, 0x9a, 0x94, 0x60, 0x1e, 0x23, 0xaa, 0xce, 0x10, 0x2c, 0x5d, 0x20, 0x27, 0x3f,
    0xda, 0x0c, 0xd9, 0xf7, 0x51, 0x08, 0x16, 0x4e, 0xaa, 0xbd, 0xba, 0x56, 0x0d, 0x99, 0xc4, 0xac,
    0x32, 0xe4, 0xd1, 0x3d, 0xd6, 0x4b, 0xa6, 0xc8, 0x9f, 0x8d, 0x65, 0x70, 0xa2, 0xbd, 0xea, 0xb3,
    0xdf, 0xda, 0x48, 0x22, 0x49, 0x90, 0x41, 0xe7, 0x57, 0x1a, 0x18, 0x53, 0x9d, 0x9a, 0xe7, 0x92,
    0x48, 0x85, 0x56, 0xa3, 0xf1, 0xeb, 0xb8, 0x5e, 0xd7, 0x2b, 0x5d, 0x13, 0x59, 0xef, 0xc4, 0x30,
    0x38, 0x8b, 0xa3, 0xe5, 0x76, 0x61, 0x84, 0xce, 0x8a, 0x38, 0x7f, 0x05, 0x58, 0x15, 0x5d, 0x84,
    0x9b, 0xdf, 0x8d, 0xfa, 0x1e, 0xb7, 0xeb, 0x6f, 0x1a, 0x0c, 0x03, 0xb5, 0x43, 0x08, 0xfd, 0xf4,
    0x2d, 0x0d, 0x2a, 0x1a, 0x6a, 0xe6, 0xa8, 0xc1, 0xeb, 0x33, 0xd4, 0x97, 0x75, 0x2a, 0xe6, 0x5b,
    0x8f, 0x64, 0x81, 0x02, 0x57, 0xb8, 0x27, 0xec, 0x7e, 0x4f, 0x5f, 0x42, 0xd1, 0xf3, 0xa2, 0x70,
    0x6d, 0xa0, 0xaa, 0xc0, 0x84, 0xfe, 0x70, 0x62, 0x6f, 0x4c, 0xb5, 0x3b, 0x6b, 0x08, 0x1c, 0xf2,
    0x78, 0x89, 0x13, 0x51, 0xd6, 0xda, 0xb1, 0xdc, 0x7f, 0xfb, 0x6d, 0x9a, 0xf4, 0x08, 0xe1, 0x02,
    0x82, 0x01, 0x01, 0x00, 0xef, 0xd3, 0x6d, 0x09, 0x8d, 0xdb, 0x97, 0xcd, 0x86, 0xcd, 0x88, 0xb2,
    0x7e, 0x32, 0xe2, 0x35, 0x18, 0xe8, 0xe6, 0x56, 0xe4, 0x2b, 0xb8, 0x91, 0xb5, 0x95, 0x6c, 0xfd,
    0x6e, 0xce, 0xff, 0x8f, 0x71, 0xb9, 0xe9, 0x2b, 0x58, 0xf9, 0x8e, 0xc4, 0x4d, 0x9d, 0xcb, 0x18,
    0x3e, 0x9d, 0x87, 0xc2, 0x73, 0xe3, 0xdc, 0xc5, 0xac, 0x62, 0x7a, 0xd5, 0xf0, 0xc2, 0xcc, 0x9f,
    0x2b, 0x1c, 0x08, 0xb0, 0xfc, 0xf6, 0x04, 0xdf, 0xe9, 0x61, 0xf5, 0x8e, 0x61, 0xd2, 0x3a, 0xc4,
    0xef, 0x9b, 0xe4, 0x45, 0xf9, 0xd4, 0x74, 0x2b, 0xa7, 0xbd, 0x30, 0x1a, 0x07, 0x20, 0xec, 0xc2,
    0xde, 0xca, 0x39, 0xa3, 0x99, 0x1a, 0x92, 0xb7, 0x1d, 0xcb, 0x9f, 0x06, 0xc8, 0xd4, 0x1c, 0x84,
    0xc8, 0xce, 0x2c, 0xe6, 0x0a, 0x7b, 0xab, 0xbe, 0xe4, 0x02, 0xbe, 0x01, 0x3f, 0x53, 0x15, 0x00,
    0xef, 0xaa, 0x3f, 0xd7, 0x56, 0x11, 0xb2, 0xa2, 0x51, 0x45, 0x60, 0x02, 0x3c, 0xc6, 0xc6, 0x11,
    0x27, 0x48, 0xad, 0x80, 0x39, 0x11, 0xf2, 0x30, 0x37, 0x8a, 0x90, 0x73, 0xf5, 0xd6, 0xf1, 0xfa,
    0x84, 0x75, 0x07, 0xe2, 0x19, 0x9c, 0x40, 0x2f, 0x3a, 0x51, 0x37, 0x0b, 0xb4, 0xbb, 0x38, 0x96,
    0xcd, 0x4e, 0xe4, 0x46, 0x61, 0xc5, 0x59, 0x93, 0x6d, 0x66, 0x90, 0xaa, 0x60, 0xf4, 0x25, 0x47,
    0x27, 0x68, 0x7e, 0x0e, 0xd6, 0xee, 0x4b, 0x3b, 0xb0, 0x3d, 0x81, 0xe9, 0xf8, 0xdc, 0x5d, 0x5b,
    0xf4, 0xaf, 0xb4, 0x4c, 0xa7, 0x05, 0x5d, 0xb3, 0x38, 0x27, 0xc8, 0x2c, 0x24, 0x68, 0x1c, 0x17,
    0xc2, 0x3e, 0xbc, 0x01, 0x1c, 0x2b, 0x92, 0xf4, 0x84, 0xb4, 0xcd, 0x1a, 0x21, 0x07, 0xd6, 0xa5,
    0xe1, 0xb6, 0x41, 0xad, 0x65, 0x22, 0x60, 0x5e, 0x13, 0xc0, 0xbb, 0x83, 0xc6, 0xc1, 0x85, 0x6e,
    0xff, 0x5d, 0x75, 0x6d, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd5, 0xd4, 0x4f, 0xe5, 0x63, 0x2b, 0x58,
    0xbf, 0xaf, 0x2a, 0x12, 0x36, 0x86, 0x68, 0xa5, 0x05, 0x30, 0x82, 0x3c, 0x9a, 0x98, 0x08, 0x60,
    0x73, 0x33, 0x1a, 0x34, 0x86, 0xb9, 0xed, 0x2e, 0xcb, 0xc2, 0x51, 0x75, 0x15, 0x8f, 0x91, 0x67,
    0x85, 0x82, 0xc3, 0x55, 0x0a, 0xdb, 0x0e, 0x33, 0xfb, 0xe6, 0xb0, 0x57, 0xfd, 0xa7, 0x52, 0x71,
    0xe4, 0x62, 0x68, 0xf5, 0x79, 0xd3, 0x12, 0xdc, 0x92, 0x85, 0x53, 0x31, 0xe6, 0xf9, 0xa8, 0x66,
    0x7b, 0x91, 0x76, 0xf1, 0x2c, 0x40, 0x3d, 0x09, 0x76, 0x0d, 0x4b, 0xff, 0x46, 0x20, 0x69, 0x0a,
    0x7d, 0x2a, 0xe6, 0x63, 0x38, 0xb2, 0x23, 0xdd, 0xc0, 0xc2, 0x69, 0x14, 0x08, 0x4a, 0x36, 0x49,
    0xda, 0xe8, 0x5e, 0xd6, 0x8d, 0xe9, 0x12, 0xd3, 0xa3, 0xc4, 0x1c, 0x93, 0x01, 0x30, 0xaa, 0x45,
    0x28, 0x5c, 0x51, 0x3b, 0x11, 0xa0, 0x70, 0xff, 0xf0, 0xad, 0x61, 0xed, 0x56, 0x3c, 0x30, 0x51,
    0x54, 0x67, 0xbd, 0xf2, 0xae, 0x93, 0x93, 0x30, 0xa2, 0x01, 0x52, 0xba, 0x1d, 0x99, 0x17, 0x6d,
    0xd9, 0x20, 0x87, 0x1d, 0x0c, 0xd2, 0xa4, 0xf8, 0xfa, 0x0e, 0x43, 0xd4, 0x06, 0x23, 0x1c, 0x80,
    0x60, 0xcf, 0x3e, 0xa5, 0x06, 0xe4, 0xc7, 0x6a, 0x1d, 0x6c, 0x30, 0xa1, 0xf6, 0x19, 0x00, 0x92,
    0x0c, 0x91, 0x71, 0x0e, 0x24, 0xb7, 0xf8, 0xf8, 0x41, 0x38, 0x22, 0xbe, 0xa4, 0x27, 0xc1, 0xc0,
    0x9c, 0x76, 0xd2, 0x33, 0x35, 0x1e, 0x30, 0x35, 0x79, 0x20, 0x57, 0xfb, 0x8d, 0x8c, 0x89, 0x54,
    0xae, 0x14, 0xb0, 0xb4, 0xd2, 0xa6, 0xfb, 0xd1, 0x9f, 0xd4, 0x3e, 0x76, 0xf6, 0xa7, 0x66, 0x86,
    0x63, 0x60, 0x20, 0x39, 0xd6, 0xb9, 0x80, 0x53, 0xa4, 0x59, 0x51, 0x0e, 0x1b, 0x5b, 0x03, 0x27,
    0x3a, 0x93, 0x84, 0xf6, 0xde, 0x70, 0x53, 0xf2, 0x4f, 0x02, 0x82, 0x01, 0x01, 0x00, 0x88, 0x9d,
    0xc3, 0x0e, 0x5f, 0x3e, 0x09, 0x72, 0xad, 0xe8, 0xe5, 0x86, 0xf0, 0x76, 0xe1, 0xff, 0x67, 0x4a,
    0x3c, 0xf4, 0xa0, 0x93, 0xfb, 0x57, 0x1d, 0xbe, 0x9a, 0x50, 0xa0, 0x4f, 0xd0, 0xab, 0x11, 0x18,
    0xdb, 0xa7, 0xb2, 0xce, 0xae, 0xb2, 0x4a, 0x98, 0xa9, 0xba, 0x0c, 0xe9, 0x46, 0x0d, 0xd2, 0x60,
    0xaa, 0x41, 0xfc, 0xda, 0x38, 0xa9, 0x28, 0xb6, 0x7f, 0x43, 0xe8, 0x95, 0xd6, 0xa9, 0xa3, 0xe0,
    0x2d, 0x94, 0xb3, 0xe8, 0xf6, 0xad, 0xfe, 0x31, 0x79, 0x02, 0xf8, 0x8f, 0xb0, 0x70, 0xe0, 0x49,
    0x53, 0x48, 0x0f, 0x0c, 0xa9, 0x9b, 0x1a, 0x16, 0x7a, 0x68, 0xe3, 0xeb, 0x04, 0xfc, 0x99, 0xd9,
    0xd6, 0x5b, 0xf3, 0xe0, 0x2b, 0x9d, 0xfc, 0xc7, 0x3f, 0xdb, 0xb0, 0x5c, 0x2a, 0x9d, 0x7c, 0xb9,
    0x48, 0x73, 0xbc, 0x85, 0x87, 0x61, 0x44, 0x86, 0x7a, 0x7f, 0x87, 0x07, 0x4f, 0xc8, 0xc6, 0x21,
    0xdc, 0xc5, 0xb4, 0x50, 0x35, 0xc9, 0xf0, 0x7f, 0x37, 0x13, 0x4c, 0x72, 0x8d, 0x4b, 0x6e, 0xb7,
    0x37, 0x64, 0x9a, 0x2f, 0x17, 0xec, 0xc6, 0xcd, 0x84, 0x18, 0xb6, 0x5d, 0xc8, 0x78, 0xd7, 0x27,
    0xf8, 0x34, 0x2f, 0x1f, 0x56, 0xa1, 0x17, 0x7a, 0x53, 0x59, 0x2c, 0x69, 0x55, 0x86, 0x76, 0x69,
    0xaa, 0x86, 0x5e, 0x1a, 0xc0, 0x2c, 0x1e, 0x80, 0xd5, 0xbf, 0x7b, 0xc6, 0x7d, 0x90, 0xcc, 0x85,
    0x00, 0x5c, 0x67, 0x20, 0x12, 0xa2, 0x8a, 0xfe, 0x55, 0x3c, 0x6d, 0xdd, 0xad, 0x72, 0xc0, 0xee,
    0x40, 0x9b, 0x38, 0x51, 0x09, 0x29, 0x84, 0x2f, 0xbe, 0x59, 0x16, 0x71, 0x10, 0x3d, 0xfd, 0xa3,
    0x20, 0xda, 0xa3, 0xc2, 0x2e, 0xd8, 0x44, 0x9a, 0xa7, 0x7e, 0xe5, 0x5e, 0x22, 0x79, 0xb9, 0x13,
    0xe5, 0x1b, 0x92, 0x5b, 0x07, 0x36, 0xa1, 0x01, 0x5a, 0x96, 0x89, 0x67, 0xde, 0xdd, 0x02, 0x82,
    0x01, 0x01, 0x00, 0xa0, 0xc2, 0xd6, 0xae, 0xa7, 0x38, 0x57, 0xa9, 0x05, 0x90, 0xa3, 0xd0, 0xca,
    0x8c, 0xb2, 0x44, 0x8c, 0x8b, 0xdd, 0xf4, 0x7c, 0x89, 0x0f, 0xba, 0x8c, 0x99, 0x0f, 0x14, 0x9b,
    0x84, 0x6e, 0xc2, 0x52, 0x7d, 0xdb, 0x81, 0x32, 0x47, 0x27, 0x85, 0x81, 0x22, 0x4a, 0x35, 0xb7,
    0x2b, 0x9e, 0x79, 0xac, 0x9e, 0xb8, 0x08, 0xc4, 0x5b, 0x7f, 0xb5, 0x2d, 0x27, 0xac, 0x26, 0xc3,
    0x42, 0x53, 0x02, 0xf5, 0xa9, 0xee, 0xc2, 0xb0, 0xc0, 0xa3, 0x0c, 0x13, 0xf9, 0x50, 0xa8, 0xec,
    0x42, 0xf7, 0x72, 0x01, 0xdd, 0x39, 0x37, 0x07, 0xf6, 0xf1, 0x23, 0xd9, 0xb5, 0x0c, 0xb3, 0xfb,
    0x7a, 0x6b, 0xa6, 0x18, 0x83, 0xd7, 0xc3, 0xc3, 0xc7, 0xbd, 0x0f, 0x0f, 0xd4, 0xfd, 0x8a, 0x03,
    0xc9, 0x5b, 0xc4, 0xac, 0x14, 0xaf, 0x91, 0x1d, 0x7d, 0x66, 0x31, 0x49, 0xf6, 0xe8, 0x6a, 0x00,
    0x2d, 0xf4, 0xbe, 0x86, 0x1c, 0x31, 0xcb, 0xbb, 0xc4, 0xb7, 0xe0, 0xb5, 0x7e, 0x61, 0x8e, 0x4e,
    0xf5, 0x42, 0x83, 0x0a, 0x6b, 0x9f, 0xf1, 0xd0, 0xbf, 0x84, 0x9e, 0xd1, 0x8d, 0xc3, 0x91, 0x78,
    0x6c, 0xff, 0xa3, 0x40, 0x46, 0x4e, 0x89, 0xae, 0xac, 0x26, 0xf8, 0xa1, 0xd7, 0x7f, 0x4b, 0x07,
    0x85, 0xc5, 0x8a, 0x09, 0x65, 0x26, 0xdf, 0x57, 0x3c, 0xce, 0x91, 0x14, 0x67, 0xe3, 0x32, 0x47,
    0xfe, 0xae, 0xe6, 0x99, 0xc5, 0xc5, 0x7e, 0xb5, 0x45, 0x3e, 0x02, 0x64, 0x72, 0xf4, 0x7c, 0xe3,
    0x0d, 0x6b, 0xa6, 0x7d, 0x62, 0xa8, 0x85, 0x6b, 0x3b, 0x74, 0xa6, 0xcc, 0x77, 0x6d, 0xfb, 0x51,
    0xff, 0xd1, 0x42, 0x50, 0xd8, 0x05, 0xa8, 0xbb, 0x82, 0xa1, 0x56, 0xe5, 0x56, 0x55, 0x25, 0xd2,
    0xa1, 0x60, 0x41, 0x17, 0xc5, 0x90, 0xcd, 0x90, 0x47, 0x76, 0x9e, 0xdb, 0x7a, 0x04, 0x00, 0x88,
    0x83, 0x14, 0x91, 0x02, 0x82, 0x01, 0x00, 0x13, 0x4b, 0x5a, 0x6d, 0x38, 0x7b, 0xaf, 0x39, 0xbc,
    0xdc, 0xaf, 0x55, 0xde, 0x65, 0x3a, 0x9b, 0xb9, 0xde, 0x1a, 0x97, 0x62, 0xd7, 0x39, 0xa1, 0x1c,
    0xf1, 0x7f, 0x10, 0x0e, 0x30, 0xfb, 0x4c, 0xb2, 0xe1, 0x6a, 0xde, 0x42, 0x35, 0xd1, 0x52, 0x8f,
    0x7b, 0x52, 0xc5, 0x58, 0x6a, 0xf5, 0x93, 0xfb, 0xe4, 0xed, 0x39, 0xc3, 0xae, 0x68, 0xe7, 0x09,
    0x4c, 0xed, 0xc9, 0x44, 0x0d, 0x84, 0x41, 0x0a, 0x45, 0xc8, 0x97, 0x93, 0x3c, 0xe1, 0xce, 0xcb,
    0x81, 0xc5, 0x45, 0x6a, 0x03, 0x46, 0x6a, 0x21, 0x95, 0x1e, 0xd6, 0xa4, 0xc6, 0x9e, 0x32, 0x46,
    0xcc, 0x31, 0x18, 0x73, 0x33, 0x27, 0xa6, 0xa8, 0xde, 0xe1, 0xdb, 0xfc, 0xed, 0x69, 0xd9, 0xcc,
    0x0c, 0x46, 0x5d, 0x59, 0x4b, 0x80, 0xf6, 0xc7, 0x79, 0xbe, 0xe1, 0xb5, 0x60, 0xae, 0x76, 0x36,
    0xa3, 0x13, 0x46, 0x8e, 0x43, 0x41, 0x0f, 0xfa, 0x1d, 0x94, 0xd8, 0x47, 0xf4, 0xcd, 0xa1, 0x57,
    0x1f, 0xf4, 0xac, 0x61, 0x40, 0x88, 0x96, 0xa7, 0x94, 0x3a, 0xff, 0xd0, 0xc5, 0x17, 0x1c, 0xa2,
    0xb6, 0xf5, 0x91, 0xda, 0xd8, 0xb6, 0x23, 0x71, 0x37, 0xcb, 0x87, 0xa9, 0x63, 0xff, 0x86, 0x31,
    0xdd, 0xf1, 0x8f, 0xf7, 0x72, 0xb1, 0x82, 0x90, 0x4d, 0x48, 0x56, 0xdd, 0x22, 0x9e, 0x2e, 0x52,
    0x3d, 0x1d, 0x84, 0xa1, 0x28, 0xfd, 0x26, 0x49, 0xe4, 0x4f, 0xc4, 0xbf, 0xd4, 0xa7, 0x65, 0x8e,
    0xf0, 0x6c, 0xf4, 0xc8, 0x5d, 0xf3, 0x87, 0xba, 0x88, 0xb2, 0x38, 0xca, 0xaa, 0x30, 0xf0, 0xbe,
    0xdf, 0xdd, 0xde, 0x6d, 0x63, 0xd5, 0x0d, 0xe1, 0x52, 0xcc, 0xb6, 0xfa, 0xaa, 0x81, 0xe2, 0xeb,
    0x3d, 0xbc, 0xc6, 0x55, 0xf2, 0x9e, 0xae, 0xaf, 0xf0, 0x98, 0xe2, 0xc1, 0xb6, 0xa1, 0x05, 0x76,
    0xe8, 0x91, 0x43, 0x3e, 0xfb, 0x72, 0x2b,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_4K_PUBLIC_KEY: [u8; 550] = [
    0x30, 0x82, 0x02, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0f, 0x00, 0x30, 0x82, 0x02, 0x0a, 0x02, 0x82, 0x02, 0x01,
    0x00, 0xc8, 0x51, 0xcf, 0xa8, 0x62, 0x9f, 0x0a, 0x4c, 0xa3, 0x6d, 0x30, 0x29, 0x65, 0x40, 0x00,
    0x60, 0x81, 0xfd, 0xf7, 0x26, 0xcd, 0xd1, 0x8b, 0x6b, 0x01, 0x3f, 0x9e, 0x6e, 0x2f, 0x54, 0xd2,
    0xb9, 0x63, 0x4e, 0xf1, 0xca, 0xd7, 0x29, 0x27, 0xdf, 0xc0, 0x2e, 0x27, 0x4c, 0xf5, 0xf0, 0x13,
    0x4d, 0xe7, 0xca, 0xad, 0xba, 0x23, 0x11, 0xfc, 0xd3, 0xfb, 0xe2, 0x0c, 0xea, 0xb5, 0x68, 0x55,
    0xb1, 0xa7, 0x9b, 0x40, 0xb0, 0x1c, 0x82, 0x74, 0x6d, 0xd4, 0x82, 0x81, 0x59, 0xe7, 0xed, 0x84,
    0x4f, 0xe4, 0x3b, 0x3e, 0x2a, 0x55, 0xbe, 0x6e, 0x16, 0x38, 0x67, 0x1d, 0xc2, 0xf5, 0x58, 0x3c,
    0x24, 0x3a, 0xc6, 0xb9, 0xaa, 0xcd, 0x31, 0xe0, 0x35, 0xe5, 0xa6, 0x5b, 0xbe, 0x40, 0x6a, 0x11,
    0x19, 0x19, 0x5c, 0x8c, 0xf5, 0x00, 0x70, 0xb3, 0x99, 0xc1, 0x13, 0xd9, 0x04, 0x05, 0xf6, 0x9c,
    0xcc, 0x15, 0x1a, 0x24, 0x16, 0x73, 0x63, 0x95, 0x02, 0x6d, 0x59, 0x27, 0x75, 0xed, 0xd3, 0x45,
    0xff, 0x99, 0xdb, 0xfb, 0x0b, 0x7d, 0xba, 0x8d, 0x94, 0x34, 0xe1, 0xe9, 0x00, 0x55, 0x35, 0xb9,
    0x4e, 0x26, 0xaf, 0xa0, 0xeb, 0x7e, 0x4b, 0xe3, 0xaa, 0xf7, 0xca, 0x9e, 0x21, 0xa3, 0x7b, 0x51,
    0xc1, 0x74, 0xa7, 0x24, 0x92, 0xad, 0xff, 0x08, 0x1f, 0x7e, 0x8d, 0xcd, 0x5b, 0x30, 0x13, 0xc9,
    0x1a, 0xd8, 0x6a, 0x6f, 0x25, 0xdf, 0xfb, 0x21, 0xc0, 0xc9, 0x9e, 0x54, 0x42, 0x15, 0x36, 0x0e,
    0x2d, 0xca, 0xe4, 0x60, 0x9e, 0xf2, 0xd9, 0x93, 0x14, 0x29, 0x9c, 0xed, 0x97, 0x02, 0x8c, 0xd0,
    0x19, 0x55, 0xc7, 0xdb, 0x80, 0x1a, 0xa8, 0x73, 0x78, 0x0c, 0x2b, 0x9d, 0x19, 0x37, 0xae, 0x6d,
    0x6a, 0x0f, 0x20, 0xc2, 0xe6, 0x6e, 0xb2, 0x11, 0x85, 0x90, 0x40, 0x12, 0x11, 0xc8, 0x1e, 0x63,
    0x02, 0xb5, 0x44, 0xad, 0xd7, 0xd8, 0x37, 0xff, 0x7a, 0x46, 0x3f, 0xbe, 0xce, 0x8d, 0xdf, 0x03,
    0x92, 0x93, 0xb0, 0x21, 0x34, 0x9c, 0x21, 0x38, 0x21, 0x3c, 0x18, 0x95, 0x2e, 0xcd, 0x04, 0x3c,
    0xa2, 0x19, 0x1f, 0xbf, 0x99, 0x6d, 0xe4, 0x5d, 0x00, 0x03, 0xc4, 0xf7, 0x09, 0x6e, 0x4b, 0x60,
    0xb5, 0x2f, 0x29, 0xe0, 0x4f, 0x04, 0x16, 0xd0, 0x59, 0x4d, 0x54, 0xfd, 0x44, 0x28, 0xb9, 0x73,
    0x05, 0x42, 0x33, 0xe5, 0x99, 0xcf, 0x83, 0xb6, 0xa9, 0xdc, 0xb4, 0x1a, 0x72, 0x34, 0xc2, 0xa8,
    0x79, 0xd8, 0x27, 0x6f, 0x3e, 0x80, 0x98, 0x01, 0xcc, 0x33, 0xc0, 0x6d, 0x1d, 0x95, 0x1a, 0x41,
    0x80, 0x3b, 0x41, 0x4c, 0xea, 0x64, 0x92, 0x74, 0xa2, 0x65, 0xf3, 0xc5, 0xff, 0xb7, 0xe4, 0x9e,
    0x5f, 0x23, 0xd3, 0x2f, 0x1a, 0x7b, 0xc1, 0x3a, 0x17, 0x9d, 0x93, 0xdb, 0x8d, 0x54, 0xb1, 0x75,
    0x0d, 0x86, 0x4b, 0x74, 0x40, 0xb0, 0x7e, 0x7a, 0x2b, 0xc0, 0x42, 0x09, 0x93, 0x8b, 0x34, 0x11,
    0x72, 0x25, 0xdb, 0x0f, 0x2c, 0x3c, 0x39, 0x24, 0xe9, 0x9a, 0x97, 0x7f, 0x04, 0x31, 0xe0, 0x17,
    0xd2, 0x21, 0x7a, 0x69, 0x27, 0xee, 0x34, 0x89, 0xbd, 0x66, 0x47, 0xe6, 0xa1, 0x0b, 0x20, 0x44,
    0x30, 0x62, 0x58, 0x6c, 0x6c, 0xbe, 0x0f, 0xb9, 0x74, 0xac, 0x56, 0x5f, 0x74, 0x4c, 0x9c, 0x90,
    0x18, 0x91, 0xdd, 0xc1, 0xd4, 0xfb, 0x83, 0x10, 0x1a, 0x77, 0xf2, 0x1e, 0x86, 0x8d, 0x19, 0xf0,
    0x77, 0x5e, 0xe2, 0x1e, 0x09, 0xbd, 0x6a, 0x16, 0xd5, 0x4a, 0xba, 0x94, 0xbc, 0xaa, 0x7a, 0x72,
    0xe2, 0x5e, 0xc9, 0x36, 0xf6, 0x30, 0x8d, 0xbe, 0x42, 0x64, 0xa4, 0x9b, 0x3a, 0x26, 0x89, 0x83,
    0xc3, 0x6c, 0x43, 0xf1, 0x48, 0xcf, 0xaa, 0x76, 0xa1, 0x7d, 0xa7, 0x5b, 0xd9, 0xe9, 0x2f, 0x46,
    0xa3, 0x02, 0x03, 0x01, 0x00, 0x01,
];

// TEST ECC KEY GENERATE STEPS:
// openssl ecparam -name secp521r1 -genkey -noout -out private_ec_key_test.pem
// openssl pkcs8 -topk8 -in private_ec_key_test.pem -inform PEM -outform DER -out ec_private_pk8.der -nocrypt
// openssl ec -in private_ec_key_test.pem -pubout -outform DER -out public_ec_key_test.der
//
// TEST ECC KEY ARRAY CONVERSION STEPS:
// xxd -i public_ec_key_test.der
// xxd -i ec_private_pk8.der

#[allow(dead_code)]
pub(crate) const TEST_ECC_256_PRIVATE_KEY: [u8; 138] = [
    0x30, 0x81, 0x87, 0x02, 0x01, 0x00, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
    0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x04, 0x6d, 0x30, 0x6b, 0x02,
    0x01, 0x01, 0x04, 0x20, 0x87, 0x59, 0x09, 0x7e, 0x21, 0xd7, 0xb2, 0x92, 0xce, 0x88, 0x13, 0xf2,
    0x19, 0x17, 0x8b, 0x57, 0xb1, 0x03, 0xcf, 0x6c, 0xf1, 0x9a, 0xee, 0xa7, 0x22, 0x44, 0xac, 0x43,
    0xd1, 0x1b, 0xd2, 0x86, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0xb0, 0x51, 0x4f, 0x91, 0x20, 0x67,
    0x1e, 0xd0, 0xfd, 0xab, 0x69, 0x81, 0x8f, 0xd3, 0x67, 0xca, 0xc1, 0x8b, 0x4e, 0x8b, 0x20, 0xf2,
    0xa4, 0x3b, 0xb8, 0x08, 0xea, 0xa1, 0xcd, 0xc0, 0x1a, 0xa8, 0x22, 0x89, 0x40, 0x9a, 0xab, 0xc6,
    0x30, 0xe8, 0x0e, 0x4a, 0x16, 0x47, 0xbf, 0x94, 0x43, 0x2e, 0xd5, 0xa3, 0x41, 0x3a, 0xd4, 0x3e,
    0x79, 0x41, 0xc1, 0x20, 0xf1, 0x56, 0x23, 0x0f, 0x51, 0x0b,
];

#[allow(dead_code)]
pub(crate) const TEST_ECC_256_PUBLIC_KEY: [u8; 91] = [
    0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,
    0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xb0, 0x51, 0x4f, 0x91, 0x20,
    0x67, 0x1e, 0xd0, 0xfd, 0xab, 0x69, 0x81, 0x8f, 0xd3, 0x67, 0xca, 0xc1, 0x8b, 0x4e, 0x8b, 0x20,
    0xf2, 0xa4, 0x3b, 0xb8, 0x08, 0xea, 0xa1, 0xcd, 0xc0, 0x1a, 0xa8, 0x22, 0x89, 0x40, 0x9a, 0xab,
    0xc6, 0x30, 0xe8, 0x0e, 0x4a, 0x16, 0x47, 0xbf, 0x94, 0x43, 0x2e, 0xd5, 0xa3, 0x41, 0x3a, 0xd4,
    0x3e, 0x79, 0x41, 0xc1, 0x20, 0xf1, 0x56, 0x23, 0x0f, 0x51, 0x0b,
];

#[allow(dead_code)]
pub(crate) const TEST_ECC_384_PRIVATE_KEY: [u8; 185] = [
    0x30, 0x81, 0xb6, 0x02, 0x01, 0x00, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
    0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x22, 0x04, 0x81, 0x9e, 0x30, 0x81, 0x9b, 0x02, 0x01,
    0x01, 0x04, 0x30, 0xce, 0xbc, 0xbb, 0x90, 0x3d, 0x9a, 0x1d, 0x46, 0xd9, 0x59, 0x15, 0x16, 0xf9,
    0x7d, 0xbe, 0x6f, 0xf6, 0x44, 0xa3, 0x2d, 0xa4, 0x7b, 0x73, 0xfb, 0x6e, 0xad, 0xa5, 0x09, 0x9a,
    0x83, 0x2a, 0x67, 0x07, 0xd2, 0x25, 0xd3, 0x8e, 0x67, 0x52, 0xcd, 0x09, 0x90, 0xa8, 0x31, 0x06,
    0x66, 0xc0, 0xe4, 0xa1, 0x64, 0x03, 0x62, 0x00, 0x04, 0xe4, 0x20, 0x9a, 0xd7, 0x07, 0xa4, 0x88,
    0x1a, 0xff, 0xf0, 0x12, 0x61, 0x92, 0xc7, 0x9d, 0x83, 0x77, 0x49, 0x21, 0xcc, 0x5d, 0xf3, 0xb9,
    0x21, 0xc4, 0x3d, 0xae, 0xaa, 0x58, 0xb8, 0x34, 0x2b, 0x38, 0x3c, 0xda, 0xb2, 0x88, 0xf0, 0xe4,
    0xb9, 0x56, 0x14, 0x11, 0x15, 0x75, 0xba, 0xbb, 0x23, 0x7c, 0x67, 0xf7, 0xd1, 0x97, 0x63, 0xc7,
    0xb8, 0x56, 0xd3, 0x22, 0xb2, 0xba, 0xba, 0x1a, 0xc6, 0xb4, 0xea, 0x0d, 0xad, 0xa2, 0x56, 0x29,
    0xd5, 0xca, 0x0f, 0x4a, 0x4e, 0xee, 0x17, 0xb0, 0xb2, 0xf4, 0xb1, 0x58, 0xba, 0xae, 0xa1, 0x58,
    0x9c, 0x10, 0x07, 0xf7, 0x0e, 0xc7, 0x62, 0x42, 0xe0,
];

#[allow(dead_code)]
pub(crate) const TEST_ECC_384_PUBLIC_KEY: [u8; 120] = [
    0x30, 0x76, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b,
    0x81, 0x04, 0x00, 0x22, 0x03, 0x62, 0x00, 0x04, 0xe4, 0x20, 0x9a, 0xd7, 0x07, 0xa4, 0x88, 0x1a,
    0xff, 0xf0, 0x12, 0x61, 0x92, 0xc7, 0x9d, 0x83, 0x77, 0x49, 0x21, 0xcc, 0x5d, 0xf3, 0xb9, 0x21,
    0xc4, 0x3d, 0xae, 0xaa, 0x58, 0xb8, 0x34, 0x2b, 0x38, 0x3c, 0xda, 0xb2, 0x88, 0xf0, 0xe4, 0xb9,
    0x56, 0x14, 0x11, 0x15, 0x75, 0xba, 0xbb, 0x23, 0x7c, 0x67, 0xf7, 0xd1, 0x97, 0x63, 0xc7, 0xb8,
    0x56, 0xd3, 0x22, 0xb2, 0xba, 0xba, 0x1a, 0xc6, 0xb4, 0xea, 0x0d, 0xad, 0xa2, 0x56, 0x29, 0xd5,
    0xca, 0x0f, 0x4a, 0x4e, 0xee, 0x17, 0xb0, 0xb2, 0xf4, 0xb1, 0x58, 0xba, 0xae, 0xa1, 0x58, 0x9c,
    0x10, 0x07, 0xf7, 0x0e, 0xc7, 0x62, 0x42, 0xe0,
];

#[allow(dead_code)]
pub(crate) const TEST_ECC_521_PRIVATE_KEY: [u8; 241] = [
    0x30, 0x81, 0xee, 0x02, 0x01, 0x00, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
    0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x23, 0x04, 0x81, 0xd6, 0x30, 0x81, 0xd3, 0x02, 0x01,
    0x01, 0x04, 0x42, 0x01, 0xc5, 0x2a, 0xa1, 0xd5, 0x11, 0x60, 0x7a, 0x8c, 0x7e, 0x70, 0x79, 0xc2,
    0xd9, 0x28, 0xf5, 0xad, 0x48, 0x8a, 0xa6, 0x42, 0x01, 0x19, 0xeb, 0x37, 0x4b, 0x0c, 0x19, 0x29,
    0xf8, 0xd3, 0xd2, 0x0c, 0xd6, 0x1f, 0x26, 0xc7, 0x90, 0xa4, 0xd6, 0x5c, 0x0b, 0x72, 0x27, 0x2d,
    0xeb, 0x41, 0xcf, 0x6e, 0xcc, 0x00, 0xec, 0x9e, 0xfb, 0x6c, 0xbb, 0xaf, 0x89, 0xb4, 0xb7, 0x93,
    0x51, 0xee, 0xc2, 0x1b, 0x16, 0xa1, 0x81, 0x89, 0x03, 0x81, 0x86, 0x00, 0x04, 0x01, 0x96, 0x7b,
    0x85, 0xda, 0x42, 0x97, 0xa0, 0x79, 0xfd, 0x6f, 0x69, 0x1b, 0x2a, 0xc2, 0x8a, 0x44, 0xba, 0xb8,
    0x2b, 0x78, 0x9b, 0xed, 0x94, 0x12, 0x88, 0x5b, 0x18, 0x46, 0xb0, 0xe8, 0x77, 0x4b, 0xa6, 0xe2,
    0x3c, 0x0d, 0x72, 0x27, 0x2e, 0x14, 0xbe, 0x17, 0xea, 0x64, 0x98, 0x2e, 0x31, 0x12, 0xf3, 0xb3,
    0x43, 0xf7, 0x91, 0xd8, 0xec, 0xb7, 0x6c, 0x54, 0x51, 0x89, 0xee, 0x51, 0x83, 0x45, 0x51, 0x00,
    0x11, 0x98, 0x05, 0x14, 0x4b, 0x18, 0x5e, 0xff, 0x5e, 0x98, 0x10, 0x98, 0x60, 0x12, 0xf2, 0x56,
    0x7b, 0xac, 0x05, 0x0e, 0xc5, 0x94, 0xe0, 0xb4, 0x97, 0x72, 0x31, 0x3b, 0x7c, 0x76, 0xe8, 0xee,
    0x88, 0xaf, 0xc4, 0x47, 0x28, 0x12, 0xcc, 0xe3, 0xd2, 0x7e, 0x6d, 0x7c, 0xa6, 0x5f, 0x96, 0x59,
    0xe3, 0x9d, 0xea, 0xd0, 0x7e, 0x19, 0x82, 0xfe, 0x53, 0x30, 0x39, 0x3e, 0xe0, 0xaa, 0x75, 0x95,
    0xe7,
];

#[allow(dead_code)]
pub(crate) const TEST_ECC_521_PUBLIC_KEY: [u8; 158] = [
    0x30, 0x81, 0x9b, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05,
    0x2b, 0x81, 0x04, 0x00, 0x23, 0x03, 0x81, 0x86, 0x00, 0x04, 0x01, 0x96, 0x7b, 0x85, 0xda, 0x42,
    0x97, 0xa0, 0x79, 0xfd, 0x6f, 0x69, 0x1b, 0x2a, 0xc2, 0x8a, 0x44, 0xba, 0xb8, 0x2b, 0x78, 0x9b,
    0xed, 0x94, 0x12, 0x88, 0x5b, 0x18, 0x46, 0xb0, 0xe8, 0x77, 0x4b, 0xa6, 0xe2, 0x3c, 0x0d, 0x72,
    0x27, 0x2e, 0x14, 0xbe, 0x17, 0xea, 0x64, 0x98, 0x2e, 0x31, 0x12, 0xf3, 0xb3, 0x43, 0xf7, 0x91,
    0xd8, 0xec, 0xb7, 0x6c, 0x54, 0x51, 0x89, 0xee, 0x51, 0x83, 0x45, 0x51, 0x00, 0x11, 0x98, 0x05,
    0x14, 0x4b, 0x18, 0x5e, 0xff, 0x5e, 0x98, 0x10, 0x98, 0x60, 0x12, 0xf2, 0x56, 0x7b, 0xac, 0x05,
    0x0e, 0xc5, 0x94, 0xe0, 0xb4, 0x97, 0x72, 0x31, 0x3b, 0x7c, 0x76, 0xe8, 0xee, 0x88, 0xaf, 0xc4,
    0x47, 0x28, 0x12, 0xcc, 0xe3, 0xd2, 0x7e, 0x6d, 0x7c, 0xa6, 0x5f, 0x96, 0x59, 0xe3, 0x9d, 0xea,
    0xd0, 0x7e, 0x19, 0x82, 0xfe, 0x53, 0x30, 0x39, 0x3e, 0xe0, 0xaa, 0x75, 0x95, 0xe7,
];

#[allow(dead_code)]
pub(crate) const TEST_TPM_ECC_PRIVATE_KEY: [u8; 185] = [
    0x30, 0x81, 0xb6, 0x02, 0x01, 0x00, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
    0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x22, 0x04, 0x81, 0x9e, 0x30, 0x81, 0x9b, 0x02, 0x01,
    0x01, 0x04, 0x30, 0x17, 0xe9, 0x1c, 0xac, 0xf7, 0xb7, 0x21, 0xd7, 0x75, 0x20, 0x02, 0x07, 0xbc,
    0xaa, 0x94, 0x2c, 0xe3, 0xb5, 0x5b, 0x78, 0x13, 0xcc, 0x8b, 0xde, 0x87, 0x65, 0x6b, 0xe1, 0x7b,
    0xc2, 0xa8, 0xcc, 0x89, 0x33, 0x4e, 0xcd, 0xaa, 0x9d, 0x1d, 0x09, 0xf1, 0xc7, 0x01, 0x1b, 0x64,
    0xeb, 0x78, 0x5b, 0xa1, 0x64, 0x03, 0x62, 0x00, 0x04, 0x1f, 0x42, 0x0d, 0x73, 0xeb, 0xf0, 0x67,
    0xc2, 0xf9, 0x77, 0xbd, 0x51, 0xab, 0xfb, 0xe1, 0xf6, 0x53, 0x19, 0xb7, 0x57, 0xe0, 0xa9, 0x20,
    0xce, 0x4f, 0x21, 0xbb, 0xd4, 0xa7, 0x84, 0x1c, 0x93, 0x45, 0xf1, 0xea, 0xd9, 0x5f, 0xe5, 0x90,
    0xab, 0x57, 0xe1, 0xea, 0xfc, 0xd2, 0x06, 0xef, 0x21, 0xa2, 0xad, 0x10, 0xd3, 0x17, 0x6e, 0x99,
    0xc8, 0x22, 0x26, 0x23, 0x08, 0x57, 0xa7, 0x56, 0x08, 0x45, 0xe3, 0xda, 0x12, 0xc7, 0xdc, 0x3a,
    0xee, 0x01, 0xfc, 0x37, 0xab, 0x1c, 0x8d, 0xc6, 0xd0, 0x64, 0x7a, 0x7d, 0xc2, 0x67, 0xfc, 0x02,
    0x7d, 0x8d, 0xa3, 0xc8, 0x01, 0x4b, 0xa4, 0x0d, 0x98,
];

#[allow(dead_code)]
pub(crate) const TEST_TPM_ECC_PUB_KEY: [u8; 120] = [
    0x30, 0x76, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b,
    0x81, 0x04, 0x00, 0x22, 0x03, 0x62, 0x00, 0x04, 0x1f, 0x42, 0x0d, 0x73, 0xeb, 0xf0, 0x67, 0xc2,
    0xf9, 0x77, 0xbd, 0x51, 0xab, 0xfb, 0xe1, 0xf6, 0x53, 0x19, 0xb7, 0x57, 0xe0, 0xa9, 0x20, 0xce,
    0x4f, 0x21, 0xbb, 0xd4, 0xa7, 0x84, 0x1c, 0x93, 0x45, 0xf1, 0xea, 0xd9, 0x5f, 0xe5, 0x90, 0xab,
    0x57, 0xe1, 0xea, 0xfc, 0xd2, 0x06, 0xef, 0x21, 0xa2, 0xad, 0x10, 0xd3, 0x17, 0x6e, 0x99, 0xc8,
    0x22, 0x26, 0x23, 0x08, 0x57, 0xa7, 0x56, 0x08, 0x45, 0xe3, 0xda, 0x12, 0xc7, 0xdc, 0x3a, 0xee,
    0x01, 0xfc, 0x37, 0xab, 0x1c, 0x8d, 0xc6, 0xd0, 0x64, 0x7a, 0x7d, 0xc2, 0x67, 0xfc, 0x02, 0x7d,
    0x8d, 0xa3, 0xc8, 0x01, 0x4b, 0xa4, 0x0d, 0x98,
];

// Steps to generate collateral for CKM HSM RSA unwrap test. Use openssl utility in Linux/WSL:
// 1- openssl rand -out ephemeral_aes 32
// 2- EPHEMERAL_AES_HEX=$(hexdump -v -e '/1 "%02X"' < ephemeral_aes)
// 3- Note: Use TEST_RSA_2K_PUBLIC_KEY as transfer key, and TEST_RSA_3K_PRIVATE_KEY as target key
// 4- openssl enc -id-aes256-wrap-pad -K $EPHEMERAL_AES_HEX -iv A65959A6 -in TEST_RSA_3K_PRIVATE_KEY.der -out TEST_RSA_3K_PRIVATE_KEY_wrapped_der
// 5- openssl pkeyutl -encrypt -in ephemeral_aes -out ephemeral_aes_wrapped_by_TEST_RSA_2K_PUBLIC_KEY -pubin -inkey TEST_RSA_2K_PUBLIC_KEY.pem -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha1 -pkeyopt rsa_mgf1_md:sha1
// 6- cat ephemeral_aes_wrapped_by_TEST_RSA_2K_PUBLIC_KEY TEST_RSA_3K_PRIVATE_KEY_wrapped_der > final_TEST_RSA_3K_PRIVATE_KEY_wrapped_der
// 7- hexdump -v -e '/1 "0x%02X,"' < final_TEST_RSA_3K_PRIVATE_KEY_wrapped_der > final_TEST_RSA_3K_PRIVATE_KEY_wrapped_der.hex
// 8- Copy the content of final_TEST_RSA_3K_PRIVATE_KEY_wrapped_der.hex into TEST_RSA_3K_PRIVATE_CKM_WRAPPED variable.
#[allow(dead_code)]
pub(crate) const TEST_EPHEMERAL_AES: [u8; 32] = [
    0x02, 0x9A, 0xD6, 0x07, 0x10, 0x43, 0x01, 0xFE, 0x11, 0xC1, 0x6A, 0x62, 0x18, 0x86, 0x4E, 0x8F,
    0x28, 0x22, 0x3A, 0xE7, 0x46, 0x88, 0x09, 0x6F, 0x15, 0x60, 0xD5, 0xCB, 0xBE, 0x43, 0x22, 0xD1,
];

#[allow(dead_code)]
pub(crate) const TEST_EPHEMERAL_AES_16: [u8; 16] = [
    0x02, 0x9A, 0xD6, 0x07, 0x10, 0x43, 0x01, 0xFE, 0x11, 0xC1, 0x6A, 0x62, 0x18, 0x86, 0x4E, 0x8F,
];

#[allow(dead_code)]
pub(crate) const TEST_EPHEMERAL_AES_24: [u8; 24] = [
    0x02, 0x9A, 0xD6, 0x07, 0x10, 0x43, 0x01, 0xFE, 0x11, 0xC1, 0x6A, 0x62, 0x18, 0x86, 0x4E, 0x8F,
    0x28, 0x22, 0x3A, 0xE7, 0x46, 0x88, 0x09, 0x6F,
];

#[allow(dead_code)]
pub(crate) const TEST_RSA_3K_PRIVATE_CKM_WRAPPED: [u8; 2064] = [
    0xE0, 0x3C, 0xF5, 0xE6, 0xF6, 0xE6, 0xF0, 0x52, 0xD6, 0x7D, 0x4F, 0xCD, 0x27, 0xC0, 0x47, 0x9D,
    0xEE, 0x85, 0x0F, 0xFB, 0x07, 0xDE, 0xC1, 0xEB, 0xC1, 0xA7, 0x5E, 0xEE, 0x84, 0x0C, 0xD9, 0xA9,
    0x4F, 0x03, 0x3C, 0x60, 0x39, 0x87, 0x8E, 0xC9, 0x51, 0x2C, 0x52, 0xB5, 0x5B, 0x6D, 0x8B, 0x1B,
    0x17, 0xDB, 0x19, 0x6A, 0x47, 0x85, 0xA9, 0x76, 0x18, 0x0F, 0x66, 0xBE, 0x0E, 0x52, 0xE0, 0xB3,
    0xC8, 0x86, 0x42, 0x16, 0x2D, 0x04, 0xBF, 0xC5, 0xE7, 0x24, 0xA9, 0x11, 0x48, 0x57, 0xC8, 0xFD,
    0xB1, 0x5C, 0x7F, 0xED, 0x12, 0x40, 0xCA, 0xA4, 0xC1, 0x61, 0x1B, 0xD8, 0x06, 0xCC, 0xA2, 0x8F,
    0x72, 0xC1, 0xA9, 0xB6, 0xD0, 0x2D, 0xD2, 0x96, 0xFC, 0x38, 0x5B, 0x85, 0xC2, 0x75, 0x49, 0x80,
    0x8C, 0x6E, 0xA0, 0x4A, 0xAE, 0x69, 0xFD, 0x2B, 0x86, 0xD6, 0xCB, 0x2A, 0xEA, 0xBE, 0xA5, 0x64,
    0xE4, 0xBC, 0x05, 0x34, 0x10, 0xAA, 0x0B, 0x9F, 0x23, 0x95, 0xF7, 0xB1, 0x5D, 0x91, 0xB0, 0xDB,
    0x72, 0x0E, 0xB0, 0x45, 0x58, 0x15, 0xE9, 0x87, 0x75, 0x67, 0xCE, 0x50, 0x7E, 0x0A, 0x99, 0xC7,
    0xC2, 0xF6, 0xEB, 0x07, 0xA3, 0x28, 0xC2, 0x9C, 0x8E, 0xBB, 0x60, 0x6A, 0x6D, 0xDA, 0x62, 0x07,
    0x15, 0xA5, 0x2C, 0xC5, 0xC2, 0x44, 0x01, 0x07, 0xC1, 0xD6, 0xE7, 0xE5, 0x82, 0x51, 0x71, 0xA5,
    0x21, 0x4D, 0x15, 0x7E, 0x21, 0xE4, 0xD4, 0x50, 0x56, 0x6B, 0xC6, 0x72, 0xD6, 0x7B, 0x47, 0x70,
    0x97, 0x22, 0xC3, 0x96, 0x90, 0xE6, 0x37, 0x39, 0x18, 0xBE, 0x0C, 0x02, 0x3F, 0xA7, 0x1C, 0x2D,
    0xA2, 0xB6, 0x88, 0x2E, 0x42, 0xE2, 0xEC, 0x27, 0x50, 0x7F, 0xF8, 0x58, 0x07, 0x9C, 0xD6, 0xC4,
    0x83, 0x75, 0xDB, 0xDA, 0xC3, 0x64, 0xE9, 0x4C, 0x1B, 0xF6, 0xAE, 0x22, 0xC9, 0x5B, 0xAB, 0xD9,
    0x1D, 0x48, 0xF9, 0x97, 0x84, 0x7B, 0x4F, 0xE6, 0x95, 0x0F, 0x67, 0x22, 0x46, 0x4C, 0xAF, 0x52,
    0xD5, 0x3B, 0xE1, 0x40, 0x5F, 0x29, 0x68, 0x32, 0x5F, 0x2A, 0x13, 0x19, 0x81, 0xE4, 0x52, 0x53,
    0x10, 0xB7, 0x78, 0xFA, 0x9F, 0x63, 0x4C, 0xB7, 0x64, 0xD3, 0xB5, 0x12, 0x31, 0xDF, 0x99, 0xC3,
    0x20, 0x59, 0xF5, 0x8D, 0x85, 0x8D, 0x32, 0x94, 0x56, 0x38, 0x74, 0xED, 0x4C, 0x03, 0x76, 0xDD,
    0xF0, 0x80, 0x50, 0x4F, 0xBA, 0xF4, 0x31, 0xF1, 0xF6, 0xFC, 0x79, 0x73, 0x45, 0xE9, 0x47, 0x78,
    0xE1, 0xA8, 0x8C, 0xD3, 0x3F, 0xE6, 0xB6, 0x13, 0x66, 0x69, 0xE2, 0x6F, 0xCC, 0xBA, 0x57, 0xCF,
    0x22, 0xB6, 0xEF, 0x39, 0x16, 0x47, 0xAD, 0x94, 0xE9, 0xDD, 0x02, 0xEF, 0xD9, 0x75, 0x18, 0x9B,
    0x43, 0xE1, 0x58, 0xEB, 0x2A, 0xBE, 0x04, 0x07, 0xAC, 0x6D, 0xBA, 0x6B, 0x17, 0x60, 0xFA, 0xFE,
    0x3E, 0x78, 0xC0, 0xD8, 0xD2, 0xE2, 0xC9, 0x36, 0xCE, 0xF4, 0xD9, 0x17, 0xB2, 0x12, 0x1A, 0xC6,
    0x98, 0x04, 0x2F, 0xEC, 0x11, 0x2F, 0x7F, 0x75, 0xBF, 0x4E, 0x7E, 0x5A, 0xD0, 0x57, 0x5F, 0x28,
    0xDB, 0x39, 0xC1, 0xE2, 0xE2, 0xCB, 0x99, 0x1F, 0x0C, 0x92, 0xDB, 0xF5, 0x19, 0xDA, 0x5D, 0xCE,
    0x40, 0xE6, 0xD8, 0xB6, 0xED, 0xB1, 0x7B, 0xF2, 0xF0, 0x2D, 0xD7, 0x00, 0x9B, 0x41, 0x27, 0x79,
    0xA7, 0xCB, 0xB5, 0x4D, 0xA7, 0x85, 0xF0, 0x56, 0xD8, 0x07, 0xD7, 0x8A, 0xC8, 0x91, 0x94, 0xC5,
    0xCD, 0xC7, 0xCF, 0xDA, 0x2F, 0xE4, 0x63, 0x3B, 0x56, 0x8D, 0x0F, 0xD7, 0x21, 0xDB, 0x6A, 0x9C,
    0xFE, 0x78, 0x85, 0x8F, 0xE5, 0x78, 0x9F, 0x75, 0xAE, 0xC9, 0x9D, 0xED, 0xE9, 0x30, 0x6C, 0xAD,
    0x26, 0x1C, 0x38, 0x0F, 0x86, 0xFB, 0xCA, 0x6E, 0xDE, 0x2A, 0xD8, 0x0A, 0x3C, 0xEE, 0x13, 0x7E,
    0xCF, 0xD6, 0xC1, 0x13, 0x0A, 0x15, 0xCD, 0xA1, 0x85, 0xE0, 0xAE, 0x92, 0xDE, 0x19, 0xAB, 0xEE,
    0xFE, 0x1A, 0x57, 0x92, 0xAA, 0xFA, 0x54, 0x54, 0xC9, 0x08, 0xD3, 0xFC, 0xBF, 0xA7, 0x58, 0x7A,
    0x72, 0x4D, 0x05, 0xBD, 0x69, 0xAA, 0x86, 0x14, 0xE3, 0x54, 0x43, 0xEC, 0x89, 0x56, 0x9C, 0x90,
    0xDB, 0x85, 0xD3, 0xE3, 0x8D, 0x5D, 0x7C, 0xD2, 0x44, 0xF7, 0x25, 0x88, 0xFE, 0x77, 0x40, 0x33,
    0x4B, 0x30, 0x54, 0xD2, 0x0D, 0x20, 0x4B, 0x77, 0x99, 0x82, 0xBB, 0x5D, 0x20, 0xEE, 0x0D, 0xE0,
    0x34, 0xEF, 0x78, 0x24, 0x9B, 0xE7, 0x4F, 0x65, 0xE9, 0xCA, 0xB4, 0xAF, 0x80, 0xAB, 0xAD, 0x2E,
    0xB3, 0xAE, 0x7F, 0xCC, 0x6D, 0xB8, 0x5D, 0x5C, 0x85, 0x52, 0x7F, 0x55, 0x40, 0x3B, 0xC1, 0x7D,
    0x38, 0x1A, 0x31, 0x56, 0xA7, 0x0E, 0x78, 0xFB, 0x83, 0x57, 0xE4, 0x5D, 0xEB, 0x9B, 0x1F, 0x3C,
    0x5C, 0xEB, 0xA4, 0xCD, 0x7B, 0xD0, 0x60, 0x1A, 0x5A, 0x32, 0x96, 0x0E, 0x52, 0x32, 0x29, 0x52,
    0xDA, 0xAA, 0xB1, 0x9A, 0x01, 0xE9, 0x79, 0xCF, 0x14, 0x9A, 0x62, 0x1F, 0x1E, 0x59, 0xA5, 0x75,
    0xF8, 0xE7, 0xE7, 0x36, 0xB2, 0x60, 0xF0, 0x1C, 0x42, 0x3C, 0xBB, 0x75, 0x01, 0x12, 0x90, 0x93,
    0xBD, 0xB3, 0x86, 0x54, 0x80, 0x7C, 0x8D, 0x73, 0x88, 0x1C, 0x28, 0xF1, 0x81, 0x2D, 0x76, 0xD3,
    0xE3, 0xA3, 0xD8, 0x4B, 0xA9, 0x3E, 0x7E, 0xD5, 0xA4, 0x56, 0xF9, 0xEA, 0x84, 0x50, 0x55, 0x0B,
    0xE6, 0x88, 0x82, 0x62, 0x0A, 0xB6, 0x34, 0x15, 0x33, 0x69, 0x7C, 0xFD, 0xEA, 0x6A, 0x74, 0x24,
    0x14, 0x8C, 0x48, 0x09, 0x55, 0x06, 0x04, 0x30, 0x30, 0x12, 0x97, 0xA6, 0x0D, 0xD1, 0xB9, 0x33,
    0x95, 0x44, 0x9A, 0x68, 0xD6, 0xAE, 0x53, 0xE4, 0x3F, 0xC3, 0xC2, 0x7C, 0xAE, 0x5F, 0x21, 0xFA,
    0x12, 0x02, 0x78, 0xA4, 0x5C, 0xDF, 0x6D, 0x01, 0x61, 0x9F, 0xA4, 0x5B, 0x33, 0x16, 0xAC, 0x26,
    0x7B, 0x89, 0x57, 0xFE, 0x1B, 0x3D, 0x81, 0xFE, 0xB3, 0x99, 0x31, 0x05, 0x68, 0xAE, 0x22, 0x1B,
    0x72, 0x19, 0x80, 0xF1, 0x05, 0x46, 0xA8, 0x3C, 0x61, 0xC6, 0x7D, 0x94, 0x47, 0xE4, 0xC8, 0x18,
    0x9A, 0xBB, 0xEC, 0x8B, 0xEA, 0x30, 0x05, 0x23, 0xAB, 0x9E, 0x15, 0x72, 0xAA, 0x01, 0x6D, 0x0B,
    0xB0, 0x27, 0xBB, 0xBF, 0x1B, 0x74, 0x4D, 0xB9, 0xF9, 0xF3, 0x41, 0x15, 0x2C, 0x88, 0x03, 0x6C,
    0xFF, 0x30, 0x05, 0xAD, 0xA9, 0x74, 0x22, 0xC0, 0x57, 0x49, 0xA6, 0xD9, 0x7D, 0x22, 0xE9, 0xBA,
    0xFC, 0xE7, 0xCA, 0x15, 0x72, 0xB5, 0xD4, 0xC2, 0x55, 0xE2, 0xF8, 0x51, 0xD4, 0x53, 0xBA, 0xF3,
    0xBF, 0xD5, 0xD3, 0x46, 0xB9, 0xD7, 0xFF, 0x40, 0xC3, 0x67, 0x0B, 0x43, 0xC8, 0x9B, 0x5B, 0x03,
    0xE5, 0x20, 0xF2, 0x68, 0xC5, 0x2E, 0x2A, 0x57, 0x6C, 0xB2, 0xE8, 0x81, 0x40, 0xA5, 0xAB, 0xAA,
    0x03, 0x3C, 0x3E, 0xE2, 0xEA, 0x6B, 0x02, 0x14, 0x3C, 0x0D, 0x76, 0x64, 0x5D, 0x9D, 0xA8, 0xD7,
    0xAF, 0xEE, 0x8A, 0x71, 0x7C, 0x9F, 0x2E, 0x5E, 0x9A, 0x9B, 0xC2, 0x6C, 0xF7, 0x2A, 0x49, 0x06,
    0x11, 0x79, 0x90, 0x2D, 0x44, 0xFF, 0x8A, 0xC2, 0x23, 0xCD, 0x2A, 0x52, 0x9F, 0x56, 0xAA, 0x1A,
    0xD6, 0x95, 0x40, 0xB8, 0x94, 0x78, 0xDF, 0x5F, 0xF3, 0x1C, 0xC1, 0x9D, 0x32, 0xEF, 0x6E, 0xAC,
    0xAF, 0xA7, 0x99, 0x78, 0xD0, 0x3F, 0x0C, 0x12, 0x4B, 0x01, 0x7E, 0x24, 0x03, 0xB8, 0x9B, 0xBE,
    0xC3, 0xE9, 0x13, 0xD1, 0x2C, 0x28, 0x12, 0xEB, 0x0D, 0xE6, 0x57, 0x10, 0x21, 0x21, 0xDF, 0xCA,
    0x82, 0x99, 0x66, 0xBF, 0x3B, 0x9A, 0x82, 0xBE, 0x5F, 0x73, 0xC2, 0x81, 0xFB, 0x19, 0x46, 0x81,
    0x64, 0x82, 0x73, 0x44, 0x1E, 0x52, 0xE3, 0xA7, 0x50, 0xE8, 0x85, 0xE6, 0x6D, 0x47, 0xE9, 0xA8,
    0x41, 0x09, 0x93, 0x17, 0x0F, 0x87, 0x82, 0xAA, 0xE4, 0x07, 0x64, 0xA2, 0x2F, 0x48, 0x0B, 0xA8,
    0x20, 0xDD, 0x72, 0xB4, 0x15, 0x05, 0xA2, 0x6A, 0x76, 0x92, 0x00, 0x74, 0x29, 0xCB, 0x3F, 0xE1,
    0x98, 0xDA, 0x2A, 0xA8, 0x29, 0xBA, 0x4F, 0xC9, 0x63, 0xE9, 0xE8, 0xB3, 0x1E, 0xA5, 0xD5, 0x2D,
    0x55, 0x8C, 0xB0, 0x25, 0xBA, 0x2D, 0xE2, 0xE2, 0xB6, 0xD6, 0xF9, 0xDF, 0x13, 0xE5, 0x56, 0x95,
    0x6B, 0x3D, 0x3E, 0x3D, 0x30, 0x5C, 0x88, 0xEC, 0x08, 0xF7, 0xE9, 0xC3, 0x86, 0xE5, 0xE7, 0xCE,
    0x40, 0xA5, 0x44, 0x06, 0x3C, 0x06, 0x3B, 0x0B, 0x8B, 0x90, 0x09, 0x9B, 0x36, 0x06, 0xB4, 0x43,
    0x2F, 0x41, 0x96, 0xC1, 0x4E, 0x91, 0xA7, 0x2F, 0xAA, 0xEB, 0x72, 0x47, 0xF8, 0xD0, 0xA3, 0x29,
    0x55, 0xC3, 0xEA, 0xDF, 0x74, 0xCF, 0x87, 0x63, 0x22, 0x52, 0xF8, 0x01, 0x23, 0xD2, 0x74, 0x85,
    0x6E, 0x3E, 0x30, 0x4A, 0x85, 0xBA, 0xE9, 0xF6, 0xA1, 0x0C, 0x89, 0x1D, 0xD0, 0x81, 0x5D, 0x01,
    0x91, 0xAA, 0xA5, 0x5C, 0x41, 0x6E, 0x17, 0xF0, 0xA8, 0x22, 0x71, 0x60, 0x18, 0xEB, 0x79, 0xA7,
    0xC3, 0x2E, 0x2D, 0x32, 0x21, 0x1D, 0xE9, 0x43, 0xD3, 0xDD, 0x85, 0x15, 0xE1, 0xAA, 0x29, 0x0E,
    0x3C, 0xD5, 0x7A, 0xCA, 0x39, 0x39, 0xD8, 0xE0, 0xDD, 0xF0, 0xD5, 0x63, 0x81, 0x64, 0xF3, 0xC6,
    0x97, 0xB5, 0x08, 0x8C, 0xFC, 0xBB, 0xF4, 0xD8, 0xA8, 0x86, 0x27, 0x88, 0x81, 0x9B, 0xB9, 0x0C,
    0x4D, 0x65, 0x4F, 0x76, 0xAA, 0x19, 0x16, 0x6F, 0xED, 0xAE, 0x8A, 0xA1, 0xDB, 0xB3, 0x68, 0x8D,
    0x1B, 0xAA, 0x93, 0x9E, 0x46, 0x30, 0x82, 0x86, 0x50, 0xD5, 0xA6, 0x51, 0x0A, 0xA1, 0xCA, 0x05,
    0xF5, 0x09, 0x41, 0x7D, 0xE4, 0xA7, 0x81, 0x47, 0xC6, 0xE3, 0xBC, 0x1F, 0x66, 0xFB, 0x34, 0x76,
    0xE6, 0xAB, 0x4B, 0xBD, 0xA3, 0x93, 0xF6, 0xCA, 0x70, 0xA4, 0xDF, 0x25, 0xEA, 0x5C, 0x25, 0x9E,
    0xA0, 0xB0, 0x95, 0x4F, 0x55, 0xE3, 0x75, 0x1B, 0xC8, 0x36, 0x82, 0xD6, 0x22, 0x7B, 0x98, 0xE0,
    0x22, 0x2C, 0xDA, 0x98, 0x15, 0x73, 0x65, 0x4A, 0x2B, 0x0D, 0x97, 0x29, 0x66, 0x60, 0x62, 0x75,
    0x8B, 0xC4, 0x3E, 0xB7, 0x6A, 0x22, 0x5A, 0xFA, 0x2B, 0x14, 0x13, 0x1D, 0xD2, 0x54, 0x34, 0x28,
    0x64, 0xC3, 0x18, 0xAC, 0x0B, 0xAB, 0x32, 0x53, 0x71, 0xA9, 0x67, 0x0B, 0x62, 0x13, 0x83, 0x0C,
    0x7E, 0x26, 0x0C, 0xAA, 0xE8, 0x07, 0x74, 0x1C, 0x7F, 0x1D, 0x7D, 0x5E, 0x2F, 0x43, 0x97, 0x66,
    0x26, 0x1B, 0x93, 0xFF, 0x2D, 0xAE, 0xC7, 0x57, 0xB3, 0xD8, 0xFE, 0x1B, 0xDB, 0x22, 0x5C, 0x0C,
    0xE1, 0xB8, 0xB4, 0x84, 0x65, 0xAC, 0x56, 0x81, 0x22, 0x72, 0x77, 0xFB, 0x8D, 0xF6, 0xA8, 0x68,
    0x0A, 0x39, 0xFA, 0xC5, 0x6C, 0x31, 0xBC, 0x24, 0x93, 0x0A, 0x7C, 0x64, 0x9F, 0xD7, 0x06, 0x7E,
    0x74, 0x76, 0x6D, 0x29, 0xE2, 0xEC, 0x3B, 0xE7, 0xAF, 0x8B, 0x83, 0x8B, 0xF6, 0x08, 0x54, 0xAC,
    0xB9, 0xA2, 0x73, 0x94, 0x8E, 0x3D, 0x47, 0x7B, 0xF1, 0x5E, 0xC7, 0x5C, 0x52, 0x4A, 0x38, 0x83,
    0xFA, 0x3A, 0x9E, 0xEF, 0x93, 0xC2, 0xBD, 0x7D, 0xBC, 0x07, 0xEF, 0x48, 0x32, 0x37, 0xE4, 0x39,
    0x4D, 0xA2, 0xAF, 0xD7, 0x8D, 0x2A, 0x58, 0x3C, 0xA0, 0xAD, 0x8C, 0x8B, 0x27, 0x28, 0x8F, 0xF9,
    0x4A, 0x37, 0x9E, 0x04, 0xFB, 0x4C, 0x14, 0x6D, 0xB1, 0x4F, 0x13, 0xBE, 0xA0, 0x16, 0x5A, 0x27,
    0x44, 0xB4, 0x54, 0xE1, 0x87, 0x12, 0xE2, 0xAE, 0x8C, 0x61, 0x31, 0x60, 0xCF, 0x8B, 0x8F, 0xB5,
    0x38, 0xE7, 0x63, 0xCB, 0x97, 0x49, 0xDC, 0x29, 0xD7, 0xDF, 0xFF, 0x8E, 0xFF, 0x0A, 0xFB, 0xA5,
    0x56, 0x5F, 0xAA, 0xAD, 0xC1, 0x94, 0xE5, 0x1F, 0xAD, 0xB1, 0xF8, 0x4A, 0x18, 0x9B, 0x79, 0x92,
    0xBD, 0xC5, 0x36, 0xC2, 0x24, 0x6A, 0xE9, 0x68, 0xA9, 0x10, 0x98, 0x34, 0x2C, 0x01, 0x92, 0xDA,
    0x27, 0x16, 0xD9, 0x04, 0x9C, 0xD2, 0xFE, 0x7E, 0xA9, 0x39, 0x42, 0xA4, 0x77, 0xE2, 0xAD, 0x97,
    0x4B, 0x05, 0x84, 0x91, 0xAC, 0xDE, 0x49, 0x87, 0xD5, 0x51, 0x40, 0x8B, 0xC1, 0x0F, 0x92, 0xFB,
    0x2A, 0x23, 0x1E, 0x4B, 0x17, 0xD9, 0x75, 0xC7, 0xAC, 0x04, 0x4B, 0x97, 0xBA, 0x2F, 0xA9, 0xB3,
    0xF0, 0x91, 0xC4, 0x8C, 0xED, 0xF9, 0x76, 0x67, 0x27, 0x94, 0x6C, 0x7B, 0x5A, 0xBD, 0xF0, 0x07,
    0xF4, 0x3D, 0xBB, 0xFF, 0xFB, 0xB3, 0xCE, 0x20, 0x69, 0x0D, 0xF5, 0xD1, 0x29, 0x85, 0x73, 0x7B,
    0x47, 0xD5, 0x26, 0x99, 0x36, 0xB3, 0xD8, 0x6B, 0x34, 0xA7, 0xB8, 0x71, 0xC9, 0x92, 0xD2, 0x80,
    0x75, 0x6A, 0x78, 0x0E, 0xD0, 0x62, 0x05, 0x21, 0x6E, 0x5B, 0x1E, 0x8D, 0x5E, 0x59, 0x14, 0xBC,
    0x02, 0x42, 0xAB, 0x47, 0x13, 0xCE, 0x5A, 0x0A, 0x09, 0x69, 0xAD, 0x57, 0x29, 0x85, 0xC4, 0x4D,
    0xE4, 0xA7, 0x21, 0xA0, 0x03, 0xE0, 0xC0, 0x9E, 0xF7, 0x06, 0x04, 0xB4, 0xE6, 0xF3, 0xBE, 0xBD,
    0xE1, 0x95, 0x62, 0xBF, 0x8C, 0x07, 0x17, 0xA3, 0x32, 0x52, 0xA6, 0x32, 0x3C, 0x5A, 0xF7, 0xA9,
    0xCC, 0x52, 0x5A, 0xF8, 0x3D, 0xAD, 0xBD, 0xA0, 0x67, 0x0C, 0x5D, 0x2B, 0x4E, 0xC5, 0x5A, 0xED,
    0x98, 0x80, 0x45, 0x6B, 0x99, 0x3B, 0xEB, 0xCE, 0xD1, 0x83, 0x7A, 0x97, 0x25, 0x93, 0x14, 0x2F,
    0xFA, 0x74, 0x0A, 0x04, 0x35, 0x07, 0xA1, 0x5F, 0xDC, 0x00, 0x29, 0x14, 0x35, 0x98, 0x70, 0x56,
    0xD5, 0x4F, 0x77, 0xFE, 0xCB, 0xEC, 0xD0, 0xC6, 0x7F, 0xF4, 0xA5, 0x65, 0xA3, 0x5D, 0xE8, 0xC8,
    0x42, 0xA1, 0xEB, 0x39, 0x07, 0xEB, 0x19, 0x13, 0xE3, 0xB5, 0xB4, 0x19, 0x36, 0x89, 0xE1, 0x87,
    0xBD, 0xA0, 0x8A, 0x38, 0xCD, 0xE3, 0x8B, 0x8D, 0x89, 0x89, 0xC7, 0xB6, 0xC5, 0x0B, 0xDD, 0xDE,
    0x31, 0x27, 0xF7, 0x3D, 0x55, 0x54, 0x9A, 0x3A, 0xA8, 0xD8, 0xE6, 0x4F, 0x92, 0x3F, 0x10, 0x10,
    0x2E, 0x74, 0x21, 0x46, 0xCA, 0x5D, 0x37, 0x69, 0xA7, 0x7F, 0x24, 0x8B, 0x60, 0xA3, 0x89, 0x86,
    0x3C, 0x65, 0x32, 0x8C, 0xEC, 0x64, 0x4C, 0x15, 0x00, 0x95, 0x9E, 0xED, 0x98, 0x42, 0x9B, 0x44,
    0xC5, 0x49, 0x65, 0xC2, 0x6B, 0xAD, 0x85, 0xB8, 0x80, 0x8B, 0x27, 0x6B, 0x40, 0x08, 0x96, 0xF1,
    0xD1, 0x22, 0xD2, 0x88, 0xC5, 0x77, 0x67, 0xA4, 0x1B, 0xBD, 0x8F, 0x92, 0x54, 0x57, 0x28, 0xF4,
    0x0D, 0x2C, 0x32, 0xD0, 0xF7, 0xF6, 0xE7, 0x2D, 0x7A, 0xB4, 0x8D, 0x17, 0xA9, 0xB3, 0xBC, 0xC8,
    0xC9, 0xDA, 0x78, 0xBE, 0x44, 0x84, 0x00, 0x17, 0x83, 0x7F, 0x4D, 0x19, 0xF4, 0xB8, 0x98, 0x3E,
    0xEB, 0xF2, 0xD7, 0x88, 0x1C, 0x0E, 0x13, 0x58, 0xA5, 0x63, 0x40, 0x88, 0x6A, 0x37, 0xFD, 0xC8,
    0x42, 0x5E, 0x2B, 0xCF, 0xEA, 0xCA, 0x5A, 0x0B, 0x7E, 0xDD, 0xA8, 0x64, 0x21, 0x22, 0xF3, 0x2A,
    0xF9, 0xF7, 0xE4, 0xB8, 0xD6, 0xC1, 0xEA, 0xAB, 0xB0, 0x8C, 0x4E, 0x02, 0x16, 0xD2, 0x94, 0x63,
    0x26, 0x7A, 0xB8, 0x25, 0x4B, 0x63, 0x3B, 0xBE, 0xF1, 0x02, 0xEF, 0x63, 0xAF, 0x37, 0xF5, 0x8B,
    0xBB, 0x53, 0xE2, 0xFE, 0xB7, 0xD5, 0x4F, 0x9A, 0x29, 0x3D, 0xAC, 0x76, 0x48, 0x28, 0x66, 0xC1,
    0x34, 0x7E, 0xD0, 0xDE, 0x30, 0x01, 0x52, 0xC7, 0xB7, 0x44, 0xF1, 0xFD, 0xBE, 0xE4, 0xD0, 0xA6,
    0x5C, 0x2A, 0x76, 0x8D, 0x0A, 0x17, 0xFF, 0x7E, 0xD9, 0x7F, 0x7C, 0x55, 0x8F, 0x55, 0xB5, 0x31,
];

#[allow(dead_code)]
pub(crate) const TEST_AES_256: [u8; 32] = [
    0x69, 0xe4, 0x04, 0xf9, 0xa6, 0x09, 0x5a, 0x04, 0xd0, 0xd6, 0x59, 0xdf, 0xfe, 0xb4, 0x44, 0x12,
    0xc3, 0x33, 0x35, 0x71, 0xf2, 0xed, 0x0f, 0x42, 0x38, 0x82, 0x3c, 0x66, 0x76, 0x2d, 0x11, 0x76,
];

// `TEST_AES_256` wrapped by `TEST_EPHEMERAL_AES` and `TEST_RSA_2K_PUBLIC_KEY``
#[allow(dead_code)]
pub(crate) const TEST_AES_256_CKM_WRAPPED: [u8; 296] = [
    0x51, 0xb3, 0x22, 0x98, 0xc5, 0x9f, 0xab, 0x74, 0x33, 0x62, 0xae, 0xf2, 0x7d, 0xe3, 0x26, 0x9b,
    0xab, 0x16, 0xf9, 0x67, 0xc5, 0x72, 0x46, 0xa2, 0x9a, 0xa5, 0x1f, 0xb1, 0x63, 0xbd, 0xd6, 0xd9,
    0x84, 0x5d, 0x19, 0x34, 0x31, 0x49, 0x7c, 0x12, 0x3d, 0xdc, 0xab, 0xda, 0x22, 0x2e, 0xe6, 0x48,
    0x55, 0x61, 0x68, 0xfb, 0x7e, 0x48, 0x43, 0x72, 0x6a, 0x80, 0x6c, 0xec, 0xfa, 0xb6, 0x2b, 0x1f,
    0xb6, 0xe1, 0x4f, 0x35, 0xa5, 0xe2, 0x55, 0x8a, 0x91, 0x62, 0x27, 0x18, 0x91, 0xf9, 0x6b, 0x6f,
    0xd3, 0x4f, 0xc8, 0xa9, 0xa5, 0xc5, 0x1b, 0x0f, 0x0c, 0x3d, 0xe4, 0xb3, 0xcb, 0x46, 0x1b, 0x19,
    0x2f, 0x14, 0x0b, 0x1d, 0x4c, 0x9d, 0x78, 0x5a, 0x11, 0x81, 0x42, 0x65, 0xf4, 0xae, 0x5c, 0x11,
    0xd9, 0xd0, 0x44, 0x90, 0xd5, 0x96, 0xa7, 0x75, 0x4a, 0x66, 0x47, 0x24, 0xdc, 0xd2, 0x84, 0x98,
    0x9d, 0x99, 0x4e, 0x1a, 0x99, 0xbf, 0x73, 0xab, 0x4d, 0x08, 0x85, 0x17, 0xe1, 0xfc, 0x22, 0xcc,
    0x95, 0x95, 0x03, 0xf4, 0x17, 0x2f, 0x56, 0xd6, 0xd7, 0xdd, 0x95, 0xd8, 0xfd, 0x1e, 0x30, 0xb6,
    0x8c, 0xe3, 0xb8, 0x5d, 0x5f, 0xe3, 0xc2, 0xb2, 0xd0, 0x55, 0xe2, 0xc2, 0x21, 0x8e, 0x43, 0x7d,
    0xc9, 0xd0, 0xa4, 0xc9, 0x33, 0xdc, 0x88, 0x40, 0x77, 0x81, 0xdc, 0x77, 0xbd, 0xa8, 0x65, 0x77,
    0x49, 0x34, 0x19, 0x41, 0xf0, 0x5b, 0x0c, 0x45, 0xb7, 0x3b, 0x0f, 0x7f, 0xec, 0xb6, 0x24, 0x42,
    0xe8, 0xa2, 0x68, 0xd3, 0x4f, 0x8d, 0x4c, 0xf9, 0x00, 0x32, 0x32, 0xb5, 0xcd, 0x0e, 0xd7, 0xb7,
    0xef, 0x1d, 0xeb, 0x07, 0x46, 0x2d, 0x07, 0x5b, 0x40, 0x2d, 0x2a, 0x9c, 0x70, 0xb1, 0x68, 0x59,
    0x3b, 0xa3, 0xfe, 0x46, 0xf0, 0xf7, 0x4c, 0x07, 0xfe, 0xd0, 0x95, 0xca, 0x0c, 0x24, 0xbe, 0x03,
    0x9c, 0xe3, 0xd0, 0x06, 0xe9, 0x0d, 0xea, 0x8d, 0x58, 0xc9, 0x5e, 0x13, 0x5c, 0xd9, 0x47, 0x3c,
    0x8f, 0x97, 0xfb, 0xaa, 0xbe, 0xe3, 0x72, 0xc6, 0xca, 0x7a, 0x1c, 0xb7, 0xaf, 0x3d, 0x88, 0xdf,
    0xa2, 0x45, 0x16, 0xba, 0x10, 0xec, 0x4e, 0x07,
];

pub type DdiTest = AzihsmDdi;

#[cfg(test)]
#[allow(dead_code)]
pub fn ddi_dev_test(
    setup: fn(&mut <DdiTest as Ddi>::Dev, &DdiTest, &str) -> u16,
    cleanup: fn(&mut <DdiTest as Ddi>::Dev, &DdiTest, &str, Option<u16>),
    test: fn(&mut <DdiTest as Ddi>::Dev, &DdiTest, &str, u16),
) {
    let ddi = DdiTest::default();
    let dev_infos = ddi.dev_info_list();

    if dev_infos.is_empty() {
        panic!("No devices found");
    }

    for dev_info in dev_infos.iter() {
        let mut dev = ddi.open_dev(&dev_info.path).unwrap();
        set_device_kind(&mut dev);

        let setup_session_id = setup(&mut dev, &ddi, &dev_info.path);
        test(&mut dev, &ddi, &dev_info.path, setup_session_id);
        cleanup(&mut dev, &ddi, &dev_info.path, Some(setup_session_id));
    }
}

#[allow(dead_code)]
pub fn open_dev_and_set_device_kind(ddi: &DdiTest, path: &str) -> <DdiTest as Ddi>::Dev {
    let mut dev = ddi.open_dev(path).unwrap();
    set_device_kind(&mut dev);

    dev
}

#[cfg(test)]
#[allow(dead_code)]
pub fn is_fips_approved_module(dev: &mut <DdiTest as Ddi>::Dev) -> bool {
    let resp = helper_get_device_info(dev, None, Some(DdiApiRev { major: 1, minor: 0 })).unwrap();
    assert_eq!(resp.hdr.op, DdiOp::GetDeviceInfo);
    assert!(resp.hdr.rev.is_some());
    assert!(resp.hdr.sess_id.is_none());
    assert_eq!(resp.hdr.status, DdiStatus::Success);

    resp.data.fips_approved
}
