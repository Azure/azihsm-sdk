// Copyright (C) Microsoft Corporation. All rights reserved.

use crypto::CryptoError;
use mcr_ddi_types::HMAC384_TAG_SIZE;

pub trait CryptEnv {
    /// Generates an HMAC384 tag for the given data and the key.
    ///
    /// # Arguments
    ///
    /// * `key`: The key to be used for tag generation.
    /// * `data`: The data to be authenticated.
    ///
    /// # Returns
    /// * `Ok([u8; 48])` - The generated HMAC384 tag.
    /// * `Err(CryptoError)` - If the tag generation fails.
    fn hmac384_tag(&self, key: &[u8], data: &[u8]) -> Result<[u8; HMAC384_TAG_SIZE], CryptoError>;

    /// Calculates the length of the data on encryption when using AES-CBC 256.
    ///
    /// # Arguments
    ///
    /// * `plaintext_len`: The length of the plaintext data.
    ///
    /// # Returns
    /// * The length of the encrypted data.
    fn aescbc256_enc_data_len(&self, plaintext_len: usize) -> usize;

    /// Encrypt data using AES-CBC 256 with the provided secret key.
    ///
    /// # Arguments
    ///
    /// * `key`: The key to be used for encryption.
    /// * `plaintext`: The data to be encrypted.
    /// * `iv`: The Initialization Vector (IV) used for the encryption. This is generated by the function and returned.
    /// * `ciphertext`: The buffer to write the encrypted data into.
    ///
    /// # Returns
    /// * `Ok(usize)` - The length of the encrypted data.
    /// * `Err(CryptoError)` - If the encryption fails.
    fn aescbc256_encrypt(
        &self,
        key: &[u8],
        plaintext: &[u8],
        iv: &mut [u8],
        ciphertext: &mut [u8],
    ) -> Result<usize, CryptoError>;

    /// Decrypt data using AES-CBC 256 with the provided secret key.
    ///
    /// # Arguments
    ///
    /// * `key`: The key to be used for decryption.
    /// * `iv`: The Initialization Vector (IV) for the decryption.
    /// * `ciphertext`: The data to be decrypted.
    /// * `plaintext`: The buffer to write the decrypted data into.
    ///
    /// # Returns
    /// * `Ok(usize)` - The length of the decrypted data.
    /// * `Err(CryptoError)` - If the decryption fails.
    fn aescbc256_decrypt(
        &self,
        key: &[u8],
        iv: &[u8],
        ciphertext: &[u8],
        plaintext: &mut [u8],
    ) -> Result<usize, CryptoError>;

    /// KBKDF (Key-Based Key Derivation Function) using HMAC-SHA384 in counter mode
    /// Following NIST SP 800-108 specification
    ///
    /// # Parameters
    /// - `key`: Key Derivation Key (KDK) - in BMK context this would be BK3
    /// - `label`: Optional label for domain separation (up to 32 bytes)
    /// - `context`: Optional context - in BMK derivation, this would be concatenation of BKS1 + BKS2
    /// - `out_len`: Desired output key length in bytes.
    /// - `output`: Output buffer to write derived key material
    ///
    /// # Returns
    /// - `Ok(())` on success
    /// - `Err(CryptoError)` on failure
    ///
    fn kbkdf_sha384(
        &self,
        key: &[u8],
        label: Option<&[u8]>,
        context: Option<&[u8]>,
        out_len: usize,
        output: &mut [u8],
    ) -> Result<(), CryptoError>;

    /// Generates random bytes using the environment's random number generator.
    ///
    /// # Arguments
    /// * `output`: The buffer to write the random bytes into.
    ///
    /// # Returns
    /// * `Ok(())` - If the random bytes were successfully generated.
    /// * `Err(CryptoError)` - If the random number generation fails.
    fn generate_random(&self, output: &mut [u8]) -> Result<(), CryptoError>;
}
